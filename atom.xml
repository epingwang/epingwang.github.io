<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[EpingWang's Blog]]></title>
  <link href="http://epingwang.me/atom.xml" rel="self"/>
  <link href="http://epingwang.me/"/>
  <updated>2015-07-03T13:43:54+08:00</updated>
  <id>http://epingwang.me/</id>
  <author>
    <name><![CDATA[Eping Wang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[风险投资协议（Term Sheet）详解]]></title>
    <link href="http://epingwang.me/blog/2015/07/03/feng-xian-tou-zi-xie-yi-%28term-sheet%29xiang-jie/"/>
    <updated>2015-07-03T10:23:34+08:00</updated>
    <id>http://epingwang.me/blog/2015/07/03/feng-xian-tou-zi-xie-yi-(term-sheet)xiang-jie</id>
    <content type="html"><![CDATA[<p>转自<a href="http://www.xyzlove.com/Transshipment/Investment/fxtzxy_Term_Sheet_xj/fxtzxy_Term_Sheet_xj.htm">桂曙光</a></p>

<blockquote><p>突然有一天，投资人对你的公司产生了投资兴趣，于是给你出了一份所谓“投资协议条款清单”（Term Sheet）。但是，包括你的团队、你的董事会、你周围的朋友在内，都没有人曾经看到过一份Term Sheet，你们都完全搞不懂这是什么意思。</p></blockquote>

<!-- more -->


<h2>风险投资协议（Term Sheet）详解之一：清算优先权</h2>

<p><strong>　　优先清算权是Term sheet中一个非常重要的条款，决定公司在清算后蛋糕怎么分配，即资金如何优先分配给持有公司某特定系列股份的股东，然后分配给其他股东。</strong></p>

<p>　　情景一：假如你是第一次创业，你正在寻找风险投资（VC），在经过跟风险投资人漫长的商业计划演示和交流之后，突然有一天，投资人对你的公司产生了投资兴趣，于是给你出了一份所谓“投资协议条款清单”（Term Sheet）。但是，包括你的团队、你的董事会、你周围的朋友在内，都没有人曾经看到过一份Term Sheet，里面的某个“清算优先权”条款是这样写的（通常是英文）：</p>

<p>　　Series A Preferred shall be entitled to receive in preference to the holders of the Common Stock a per share amount equal to 2x the Original Purchase Price……</p>

<p>　　A系列优先股有权优先于普通股股东每股获得初始购买价格2倍的回报……</p>

<p>　　你完全搞不懂这是什么意思。</p>

<p>　　情景二：假如你接受了上面那份Term Sheet，投资人跟你投资了$2M，给你的投资前估值（Pre-money valuation）是$3M，投资后（Post-money）估值$5M，于是投资人拥有你公司40%的股份。经过1年，公司运营不是很好，被人以$5M的价格并购。你认为你手上60%的股份可以分得$2.5M的现金，也还满意。但是投资人突然告诉你，根据协议，他要拿走$4M（投资额的2倍），留给你的只有$1M。你又糊涂了。</p>

<h3>什么是清算优先权（Liquidation Preference）？</h3>

<p>　　几乎所有的VC都选择可转换优先股（Convertible preferred stock）的投资方式，而可转换优先股的最重要的一个特性就是拥有清算优先权。</p>

<p>　　优先清算权是Term sheet中一个非常重要的条款，决定公司在清算后蛋糕怎么分配，即资金如何优先分配给持有公司某特定系列股份的股东，然后再分配给其他股东。例如，A轮（Series A）融资的Term sheet中，规定A轮投资人，即A系列优先股股东（Series A preferred shareholders）能在普通股（Common）股东之前获得多少回报。同样道理，后续发行的优先股（B／C／D等系列）优先于A系列和普通股。也就是说投资人在创业者和团队之前收回他们的资金。</p>

<p>　　通常所说的清算优先权有两个组成部分：优先权（Preference）和参与分配权（Participation）。参与分配权，或者叫双重分配权（Double Dip）有三种：无参与权（Non participation）、完全参与分配权（Full participation）、附上限参与分配权（Capped participation），相应的就有三种清算优先权：
　　
　　</p>

<h4>一、不参与分配优先清算权（Non-participating liquidation preference）</h4>

<p>　　参考下面实例：</p>

<blockquote><p>　　Liquidation Preference: In the event of any liquidation or winding up of the Company, the holders of the Series A Preferred shall be entitled to receive in preference to the holders of the Common Stock a per share amount equal to [x] the Original Purchase Price plus any declared but unpaid dividends (the Liquidation Preference).</p></blockquote>

<p>　　清算优先权：在公司清算或结束业务时，A系列优先股股东有权优先于普通股股东获得每股[x]倍于原始购买价格的回报以及宣布但尚未发放的股利（清算优先权）。</p>

<p>　　这就是实际的清算优先权，退出回报如下图：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/不参与分配优先清算权情况下的退出回报.jpg">
　　</p>

<ul>
<li>当公司退出价值（Exit Value）低于优先清算回报时，投资人拿走全部清算资金；</li>
<li>当公司退出价值按投资人股份比例分配的数额高于优先清算回报时，投资人将优先股转换成普通股，跟普通股股东按比例分配；</li>
<li>当公司退出价值介于两者之间时，投资人拿走约定的优先清算回报额。</li>
</ul>


<p>　　在普通股股东获得利益分配之前，投资人要获得原始投资一个确定倍数的回报。在过去很长时间里，标准的是“1倍（1X）”清算优先权。目前现在大部分情况是1倍（1X）至2倍（2X）。</p>

<h4>二、完全参与分配优先清算权（Full-participating liquidation preference）</h4>

<p>　　完全参与分配权的股份在获得清算优先权的回报之后，还要跟普通股按比例分配剩余清算资金。在优先权条款后还会附加以下条款：</p>

<blockquote><p>　　Participation: After the payment of the Liquidation Preference to the holders of the Series A Preferred, the remaining assets shall be distributed ratably to the holders of the Common Stock and the Series A Preferred on a common equivalent basis.</p></blockquote>

<p>　　参与权：在支付给A系列优先股股东清算优先权回报之后，剩余资产由普通股股东与A系列优先股股东按相当于转换后股份比例进行分配。</p>

<p>　　退出回报如下图所示：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/完全参与分配优先清算权情况下的退出回报.jpg"></p>

<p>　　当公司退出价值低于优先清算回报时，投资人拿走全部清算资金。超过优先清算回报部分，投资人和普通股股东按股权比例分配。
　　</p>

<h4>三、附上限参与分配优先清算权（Capped-participating liquidation preference）</h4>

<p>　　附上限参与分配权表示优先股按比例参与分配剩余清算资金，直到获得特定回报上限。在优先权条款后会附加以下条款：</p>

<blockquote><p>　　Participation: After the payment of the Liquidation Preference to the holders of the Series A Preferred, the remaining assets shall be distributed ratably to the holders of the Common Stock and the Series A Preferred on a common equivalent basis; provided that the holders of Series A Preferred will stop participating once they have received a total liquidation amount per share equal to [X] times the Original Purchase Price, plus any declared but unpaid dividends. Thereafter, the remaining assets shall be distributed ratably to the holders of the Common Stock.</p></blockquote>

<p>　　参与权：在支付给A系列优先股股东清算优先权回报之后，剩余资产由普通股股东与A系列优先股股东按相当于转换后股份比例进行分配；但A系列优先股股东一旦其获得的回报达到[x]倍于原始购买价格以及宣布但尚未发放的股利，将停止参与分配。之后，剩余的资产将由普通股股东按比例分配。</p>

<p>　　退出回报如下图所示：</p>

<p>　　
<img class="center" src="http://epingwang.me/images/2015/07/附上限参与分配优先清算权情况下的退出回报.jpg"></p>

<ul>
<li>当公司退出价值低于优先清算回报时，投资人拿走全部清算资金；</li>
<li>当公司退出价值按投资人股份比例分配的数额高于回报上限时，投资人将优先股转换成普通股，跟普通股股东按比例分配；</li>
<li>当公司退出价值介于两者之间时，投资人先拿走优先清算回报，然后按转换后股份比例跟普通股股东分配剩余清算资金，直到获得回报上限。</li>
</ul>


<p>　　这里一个有意思的问题是原始购买价格倍数（[X]）的真实含义。如果参与分配倍数是3（3X）（3倍的初始购买价格），表示一旦获得300%的初始购买价格的回报（包括优先清算的回报），优先股股东将停止参与分配剩余资产。如果清算优先权是1倍（1X）回报的话，参与分配权的回报不是额外的3倍，而是额外的2倍！也许是因为参与权跟优先权的这种关系，清算优先权条款通常同时包含优先权和参与分配权的内容。</p>

<h3>清算优先权激活：清算事件（Liquidation Event）</h3>

<p>　　谈清算优先权，那明确什么是“清算”事件就很重要。通常，企业家认为清算事件是一件“坏”事，比如破产或倒闭。对VC而言，清算就是“资产变现事件”，即股东出让公司权益而获得资金，包括合并、被收购、或公司控制权变更。结果是，清算优先权条款决定无论公司在好坏情况下，资金的分配方式。</p>

<p>　　标准条款如下：</p>

<blockquote><p>　　A merger, acquisition, sale of voting control or sale of substantially all of the assets of the Company in which the shareholders of the Company do not own a majority of the outstanding shares of the surviving corporation shall be deemed to be a liquidation.</p></blockquote>

<p>　　公司合并、被收购、出售控股股权、以及出售主要资产，从而导致公司现有股东在占有续存公司已发行股份的比例不高于50%，以上事件可以被视为清算。</p>

<p>　　所以这个条款是确定在任何非IPO退出时的资金分配（IPO之前，优先股要自动转换成普通股，清算优先权问题就不存在了），而大部分的公司最后可能的退出方式往往不会是IPO，所以不管创业者对自己和公司是否有信心，都应该详细了解这个条款。
　　</p>

<h3>清算优先权背后的逻辑</h3>

<p>　　很多VC采用有参与权优先股，一方面是因为他们基金的出资人——有限合伙人（Limited Partner，LP）也是这样向他们收取回报的。VC的普通合伙人（General Partner，GP）向LP募集资金，成立一个基金（Fund），LP出资（GP也可能会出1%），GP运营，到基金存续期结束清算的时候，LP拿走出资额外及基金盈利的80%，GP获得盈利的20%。比如：一个$100M的VC基金，LP实际上是借给VC公司$100M，LP需要拿回他们的$100M，外加80%的利润。</p>

<p>　　另外一方面，为了避免创业者从投资人那里不当获利，让VC基金蒙受损失。比如：你从投资人那里获得$10M投资，出让50%股份。然后在VC的资金到账后立刻关闭公司（没有其它资产），那投资人只有得到企业价值（$10M）的50%，这样你就从投资人那里欺骗到$5M。要是真的这样，以后你的基金就很难募到资金了。为了避免出现这种情况，也因为投资人一贯的贪婪本质，他们会要求最少1倍（1X）的清算优先权，这样在公司发展到退出价值超过投资人的投资额之前，你是不会关闭公司的。
　　</p>

<h3>创业者如何理解清算优先权</h3>

<p>　　（1）优先股是债权（Liability）还是权益（Equity）</p>

<p>　　优先股是企业的债权或是权益，参与分配权的优先股既是债权也是权益。“优先权”表示债权，“参与分配权”表示权益；</p>

<p>　　参与分配的优先股股东，不需要决定是拿走优先清算额，还是转换成普通股按比例参与分配，他们两者都要。根据上文不同情形下的退出分配图，仔细分析就会发现，参与分配的优先股只有在退出价值较小时才合理，以保护投资人的利益。如果公司运营非常好，投资人不应该按照优先清算的方式参与分配，他们会转换成普通股。</p>

<p>　　（2）投资人与创业者存在退出利益不一致</p>

<p>　　在不参与分配和附上限参与分配的清算优先权情况下，会出现一个非常奇怪的回报情形：通常投资人在某个退出价值区间的回报保持不变，比如，在退出价值X和X+a之间，投资人的回报没有区别（维持优先清算额或回报上限）。但是创业者的回报在退出价值X和X+a之间是不断升高的，此时出现双方利益不一致。如果此时公司有机会被收购，出价范围刚好在X和X+a之间，为了促成交易，投资人当然愿意接受一个底价。</p>

<p>　　（3）了解投资人要求清算优先倍数的动因</p>

<p>　　创业者要了解给你投资的VC基金，这个基金其它投资案例运营得怎么样，因为绝大多数情况下，这些投资案例的情况会决定VC如何看待你的公司。如果某个基金的其他投资案例都表现糟糕，那基金的策略会更为保守，要求的清算优先倍数会高一些，并通过投资你的公司来提升基金的整体回报水平，这样他们才能继续运作这个基金，并募集新的基金。如果某个基金投资了很多好项目，那么他们可能表现得激进一些，只想着做个大的（IPO），在清算优先倍数上不太在意。不同的VC根据你的公司在他的基金中的地位会有不同的风险／回报判断。</p>

<p>　　（4）要仔细研究并跟投资人谈判</p>

<p>　　没有一个VC打算在你没有看过并且没有给你的律师看之前，跟你签署任何东西。想一想：我打算给你能够买20或30辆保时捷汽车的资金，因为我相信你是个聪明的商人，能够让我搭顺风车一起赚钱。我会把这些真金白银给一个没有看过合同就签约的家伙吗？VC不愿意把钱给一个草率得甚至都不愿意花点时间来理解Term Sheet的家伙。最好还是找个律师或财务顾问来帮你研究一下。</p>

<p>　　我编制了一个Excel表格帮助创业者模拟融资条款中不同的清算权和参与分配权的退出回报情况。你可以改变稀释比例、优先股的参与分配权、优先清算倍数、回报上限、退出的价值范围等。改变模型中的这些变量，就可以看到管理层和投资者的回报情况。
　　
　　Excel表格下载：<a href="http://www.xyzlove.com/Transshipment/Investment/fxtzxy_Term_Sheet_xj/LiquidationPreferenceCalculation-Chinese.xls">Liquidation Preference Calculation（中文版）</a>;<a href="http://www.xyzlove.com/Transshipment/Investment/fxtzxy_Term_Sheet_xj/LiquidationPreferenceCalculation-English.xls">Liquidation Preference Calculation（英文版）</a>。
　　</p>

<h3>后续融资的清算优先权</h3>

<p>　　在谈判A轮融资的Term Sheet时，清算优先权通常比较容易理解和评估。但是随着公司发展，后续的股权融资将使得不同系列股份之间清算优先权在数量上和结构上发生变化，清算优先权也会变得更为复杂和难于理解。跟很多VC相关问题一样，处理不同系列股份清算优先权的方式也不是一成不变。通常有两种基本方式：</p>

<ol>
<li>后轮投资人将会把他们的优先权置于前轮投资人之上，比如，B轮投资人先获得回报，然后才是A轮投资人；</li>
<li>所有投资人股份平等，比如A轮和B轮投资人按比例获得优先回报。</li>
</ol>


<p>　　运用那种方法是一个黑箱艺术，是不同系列优先股之间的事情，通常不会影响创业者，因为创业者的普通股优先级最低！
　　</p>

<h3>一个清算优先权案例</h3>

<p>　　假设ABC公司的投资前估值$10M，投资额$5M，投资人要求参与分配的清算优先权倍数为2倍（2X），清算回报上限是4倍（4X）。</p>

<p>　　根据以上数据，投资人的股份（可转换优先股）比例为33%（$5M / ($10M + $5M)），优先清算额为$10M（$5M x 2），清算回报上限是$20M（$5M x 4）：</p>

<ul>
<li>如果公司清算时的价值低于投资人的优先清算额，即$10M，那么投资人拿走全部；</li>
<li>如果公司清算时的价值高于$60M，那么投资人会将优先股转换为普通股，与普通股股东按股份比例（33%）分配清算价值，投资人获得的回报将大于$20M（$60M x 33%），而不受优先股清算回报上限（$20M）的限制；</li>
<li>如果公司清算时的价值介于$10M至$60M之间，投资人先获得优先清算额（$10M），然后按股份比例跟普通股股东分配剩余的清算价值。此时会有一个有趣的情况：当清算价值介于$40M至$60M之间时，投资人拿走优先清算额之后，剩余的清算价值为$30-50M，投资人按股份比例理论上可以分配的金额为$10-16.7M，两项相加投资人获得的回报为$10-26.7M，突破了清算回报上限$20M了，因此，按照约定，此时投资人仍然只能获得$20M，多于的部分由普通股股东分配。</li>
</ul>


<p>　　具体回报如下图所示：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/清算优先权案例示意图（一）.jpg"></p>

<p><img class="center" src="http://epingwang.me/images/2015/07/清算优先权案例示意图（二）.jpg"></p>

<h3>谈判后可能的清算优先权条款</h3>

<p>　　创业者在跟VC就清算优先权谈判时，根据双方的谈判能力，公司受投资人追捧的程度，公司的发展阶段等等因素，可能或得到不同的谈判结果：</p>

<p>　　（1）有利于投资人的条款：1倍（1X）或几倍清算优先权，附带无上限的参与分配权。</p>

<p>　　在公司清算或结束业务时，A系列优先股股东有权优先于普通股股东获得每股[1]倍于原始购买价格的回报以及宣布但尚未发放的股利（清算优先权）。在支付给A系列优先股股东清算优先权回报之后，剩余资产由普通股股东与A系列优先股股东按相当于转换后股份比例进行分配。</p>

<p>　　在这个条款下，投资人不但可以获得优先清算回报，还可以不用转换成普通股就能跟普通股股东按比例分配剩余清算资金。只能说这个投资人太贪婪了。</p>

<p>　　（2）相对中立的条款：1倍（1X）或几倍的清算优先权，附带有上限的参与分配权。</p>

<p>　　在公司清算或结束业务时，A系列优先股股东有权优先于普通股股东获得每股[1]倍于原始购买价格的回报以及宣布但尚未发放的股利（清算优先权）。在支付给A系列优先股股东清算优先权回报之后，剩余资产由普通股股东与A系列优先股股东按相当于转换后股份比例进行分配；但是一旦A系列优先股股东获得的每股回报达到[3]倍于原始购买价格（除宣布但尚未发放的股利外）后将停止参与分配。之后，剩余的资产将由普通股股东按比例分配。</p>

<p>　　这个条款通常双方都愿意接受，但需要在清算优先倍数和回报上限倍数达成一致。通常的清算优先权倍数是1-2倍（1-2X），回报上限倍数通常是2-3倍（2-3X）。</p>

<p>　　（3）有利于创业者的条款：1倍（1X）清算优先权，无参与分配权。</p>

<p>　　在公司清算或结束业务时，A系列优先股股东有权优先于普通股股东获得每股[1]倍于原始购买价格的回报以及宣布但尚未发放的股利（清算优先权）。在支付给A系列优先股股东清算优先权回报之后，剩余资产由普通股股东按股份比例进行分配。</p>

<p>　　这是标准的1倍（1X）不参与分配的清算优先权（Non-participating liquidation preference）条款。意思是退出时，A系列优先股投资人可以选择要么在其他任何人之前拿回自己的投资额（仅仅是投资额），要么转换成普通股之后跟其他人按比例分配资金。没有比这个对创业者更友好的条款了，如果在你的Term sheet中出现了，恭喜你。这完全决定于你目前业绩、经济环境、第几轮融资、项目受追捧情况等。如果创业者没有令人激动的创业经历或者项目没有太多投资人关注，通常在A轮Term sheet中不会看到这样的条款。
　　</p>

<h3>总结</h3>

<p>　　大部分专业的、理性的投资人并不愿意榨取企业过高的清算优先权。优先于管理层和员工的清算优先回报越高，管理层和员工权益的潜在价值越低。每个案例的情况不同，但有一个最佳的平衡点，理性的投资人希望获得“最佳价格”的同时保证对管理层和员工“最大的激励”。很明显，最后的结果需要谈判，并决定于公司的阶段、议价能力、当前资本结构等，但通常大部分创业者和投资人会根据以上条件达到一个合理的妥协。
　　</p>

<h2>风险投资协议（Term Sheet）详解之二：防稀释条款</h2>

<blockquote><p>　　防稀释条款通常是精明的投资人为了在后续低价融资时，保护自己的利益一种方式。对创始人来说，防稀释条款通常是融资中的一部分，理解其中的细微差异和了解谈判的要点是创业者很重要的创业技能。</p></blockquote>

<p><img class="center" src="http://epingwang.me/images/2015/07/风险投资协议（Term" title="Sheet）详解之二：防稀释条款.jpg" ></p>

<p>　　风险投资人对某公司进行投资时，通常是购买公司某类优先股（A、B、C……系列），这些优先股在一定条件下可以按照约定的转换价格（conversion price）转换成普通股。为了防止其手中的股份贬值，投资人一般会在投资协议中加入防稀释条款（anti-dilution provision）。</p>

<p>　　防稀释条款，或者叫价格保护机制，已经成为大多数VC的Term Sheet中的标准条款了。这个条款其实就是为优先股确定一个新的转换价格，并没有增发更多的优先股股份。因此，“防稀释条款”导致“转换价格调整”，这两个说法通常是一个意思。</p>

<p>　　防稀释条款主要可以分成两类：一类是在股权结构上防止股份价值被稀释，另一类是在后续融资过程中防止股份价值被稀释。</p>

<p>　　（下文以A系列优先股为例讲解）
　　</p>

<h3>结构性防稀释条款（Structural anti-dilution）</h3>

<p>　　结构性防稀释条款包括两个条款：转换权和优先购买权。</p>

<p><strong>　　（1）转换权（Conversion）</strong></p>

<p>　　这个条款是指在公司股份发生送股、股份分拆、合并等股份重组情况时，转换价格作相应调整。这个条款是很普通而且是很合理的条款，也完全公平，通常企业家都能够接受。Term Sheet中的描述如下：</p>

<p>　　Conversion: The Series A Preferred initially converts 1:1 to Common Stock at any time at option of holder, subject to adjustments for stock dividends, splits, combinations and similar events and as described below under &ldquo;Anti-dilution Provisions.&rdquo;</p>

<p>　　<strong>转换权</strong>：A系列优先股股东可以在任何时候将其股份转换成普通股，初始转换比例为1:1，此比例在发生股份红利、股份分拆、股份合并及类似事件以及“防稀释条款”中规定的情况时做相应调整。</p>

<p>　　举例来说：优先股按照$2/股的价格发行给投资人，初始转换价格为$2/股。后来公司决定按照每1股拆分为4股的方式进行股份拆分，则新的转换价格调整成$0.5/每股，对应每1股优先股可以转为4股普通股。</p>

<p><strong>　　（2）优先购买权（Right of first refusal）</strong></p>

<p>　　这个条款要求公司在进行B轮融资时，目前的A轮投资人有权选择继续投资获得至少与其当前股权比例相应数量的新股，以使A轮投资人在公司中的股权比例不会因为B轮融资的新股发行而降低。另外，优先购买权也可能包括当前股东的股份转让，投资人拥有按比例优先受让的权利。</p>

<p>　　这也是一个很常见且合理的条款，Term Sheet中的描述如下：</p>

<p>　　Right of First Refusal: Investors shall have the right in the event the Company proposes to offer equity securities to any person (other than the shares reserved as employee shares described under &ldquo;Employee Pool&rdquo; and other customary exceptions) to purchase their pro rata portion of such shares (based on the number of shares then outstanding on an as-converted and as-exercised basis).</p>

<p>　　<strong>优先购买权</strong>：投资人有权在公司发行权益证券的时候（发行“期权池”股份及其他惯例情况除外）按其股份比例（完全稀释）购买相应数量的股份。</p>

<h3>降价融资的防稀释保护权（Anti-dilution protection in Down Round）</h3>

<p>　　公司在其成长过程中，往往需要多次融资，但谁也无法保证每次融资时发行股份的价格都是上涨的，风险投资人往往会担心由于下一轮降价融资（Down Round），股份的发行价格比自己当前的转换价格低，而导致自己手中的股份贬值，因此要求获得保护条款。</p>

<p>　　防稀释条款通常是一个公式，它决定优先股在转换成普通股时的数量。大部分的公式基于优先股的“转换价格”，而最开始的转换价格就是投资人购买优先股的价格（Initial Purchase Price）。在公司以低于本轮的价格进行了后续融资之后，转换价格就会降低。</p>

<p>　　所以，如果没有以更低价格进行发行股份（后续融资），初始的购买价格跟转换价格就是一样的（假定没有结构性稀释），优先股也将按1:1转换成普通股。如果后续以更低价格发行了1次或多次股份，转换价格就会比初始购买价格低，优先股能转换成更多的普通股。根据保护程度的不同，优先股的转换价格保护主要分为“完全棘轮”调整以及“加权平均”调整两种方式。</p>

<p>　　Term Sheet中的描述如下：</p>

<blockquote><p>　　Anti-dilution Provisions: The conversion price of the Series A Preferred will be subject to a broad-based weighted average adjustment to reduce dilution in the event that the Company issues additional equity securities at a purchase price less than the applicable conversion price.</p></blockquote>

<p>　　<strong>防稀释条款</strong>：如果公司发行新的权益证券的价格低于当时适用的A系列优先股转化价格，则A系列优先股的转换价格将按照广义加权平均的方式进行调整以减少投资人的稀释。</p>

<p>　　<strong>（1）完全棘轮条款（Full-ratchet anti-dilution protection）</strong></p>

<p>　　完全棘轮条款就是说如果公司后续发行的股份价格低于A轮投资人当时适用的转换价格，那么A轮的投资人的实际转化价格也要降低到新的发行价格。这种方式仅仅考虑低价发行股份时的价格，而不考虑发行股份的规模。在完全棘轮条款下，哪怕公司以低于A系列优先股的转换价格只发行了一股股份，所有的A系列优先股的转化价格也都要调整跟新的发行价一致。</p>

<p>　　举例来说，如果A轮融资$200万，按每股优先股$1的初始价格共发行200万股A系列优先股。由于公司发展不如预想中那么好，在B轮融资时，B系列优先股的发行价跌为每股$0.5，则根据完全棘轮条款的规定，A系列优先股的转换价格也调整为$0.5，则A轮投资人的200万优先股可以转换为400万股普通股，而不再是原来的200万股。</p>

<p>　　完全棘轮条款是对优先股投资人最有利的方式，使得公司经营不利的风险很大程度上完全由企业家来承担了，对普通股股东有重大的稀释影响。为了使这种方式不至于太过严厉，有几种修正方式：（1）只在后续第一次融资（B轮）才适用；（2）在本轮投资后的某个时间期限内（比如1年）融资时才适用；（3）采用“部分棘轮（Partial ratchet）”的方式，比如“半棘轮”或者“2/3棘轮”，但这样的条款都很少见。</p>

<p>　　<strong>（2）加权平均条款（Weighted average anti-dilution protection）</strong></p>

<p>　　尽管完全棘轮条款曾经很流行，现在也常常出现在投资人的Term Sheet里，但最常见的防稀释条款还是基于加权平均的。</p>

<p>　　在加权平均条款下，如果后续发行的股份价格低于A轮的转换价格，那么新的转换价格就会降低为A轮转换价格和后续融资发行价格的加权平均值，即：给A系列优先股重新确定转换价格时不仅要考虑低价发行的股份价格，还要考虑其权重（发行的股份数量）。</p>

<p>　　这种转换价格调整方式相对而言较为公平，计算公式如下（作为Term Sheet的附件或置于条款之中）：
　　
<img class="center" src="http://epingwang.me/images/2015/07/“加权平均”转换价格调整方式的公式.jpg"></p>

<p>　　NCP = A系列优先股的调整后新转换价格</p>

<p>　　CP = A系列优先股在后续融资前的实际转换价格</p>

<p>　　OS = 后续融资前完全稀释（full dilution）时的股份数量或已发行优先股转换后的股份数量</p>

<p>　　NS = 后续融资实际发行的股份数</p>

<p>　　SNS = 后续融资额应该能购买的股份（假定按当时实际转化价格发行）</p>

<p>　　IC = 后续融资现金额（不包括从后续认股权和期权执行中收到的资金）</p>

<p>　　加权平均条款有两种细分形式：广义加权平均（broad-based weighted average）和狭义加权平均（narrow-based weighted average），区别在于对后轮融资时的已发行股份（outstanding shares，即上面公式中的OS）及其数量的定义。（a）广义加权平均条款是按完全稀释方式（full diluted）定义，即包括已发行的普通股、优先股可转换成的普通股、可以通过执行期权、认股权、有价证券等获得普通股数量，计算时将后续融资前所有发行在外的普通股（完全稀释时）认为是按当时转换价格发行；（b）狭义加权平均只计算已发行的可转换优先股能够转换的普通股数量，不计算普通股和其他可转换证券。</p>

<p>　　广义加权平均时，完全稀释的股份数量很重要，即包括所有已发行和将发行的股份（优先股转换、执行期权和认股权、债转股等），企业家要确认跟投资人的定义是一致的。相对而言，狭义加权平均方式对投资人更为有利，公式中不把普通股、期权及可转换证券计算在内，因此会使转换价格降低更多，导致在转换成普通股时，投资人获得的股份数量更多。</p>

<p>　　仍拿上例来说，如果已发行普通股为800万股，新融资额为$300万，按$0.5的价格发行600万B系列优先股。则广义加权平均时新的转换价格为：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/“广义加权平均”时新的转换价格计算方式.jpg"></p>

<p>　　而狭义加权平均时新的转换价格为：
　　
<img class="center" src="http://epingwang.me/images/2015/07/“狭义加权平均”时新的转换价格计算方式.jpg"></p>

<p>　　A轮投资人投资的$200万分别可以转换为246万和320万股，相对前面的400万股，要公平一些。
　　</p>

<h3>防稀释条款的谈判要点</h3>

<p>　　企业家和投资人通常对结构性防稀释条款不会有什么争议，主要谈判内容是针对后续降价融资的防稀释保护条款。</p>

<p>　　<strong>（1）企业家要争取“继续参与”（pay-to-play）条款</strong></p>

<p>　　这个条款要求，优先股股东要想获得转换价格调整的好处（不管是运用加权平均还是棘轮条款），前提是他必须参与后续的降价融资，购买等比例的股份。如果某优先股股东不愿意参与，他的优先股将失去防稀释权利，其转换价格将不会根据后续降价融资进行调整。</p>

<p>　　Term Sheet中的描述如下：</p>

<blockquote><p>　　Pay-to-Play: On any subsequent down round all Investors are required to participate to the full extent of their participation rights, unless the participation requirement is waived for all Investors by the Board. All shares of Series A Preferred of any Investor failing to do so will automatically lose anti-dilution rights.</p></blockquote>

<p>　　<strong>继续参与</strong>：所有投资人都要完全参与后续可能的降价融资，除非董事会允许所有投资人都放弃参与，任何没有参与的投资人的A系列优先股将自动失去防稀释权利。</p>

<p>　　<strong>（2）列举例外事项</strong></p>

<p>　　通常，在某些特殊情况下，低价发行股份也不应该引发防稀释调整，我们称这些情况为例外事项（exceptions）。显然，对公司或企业家而言，例外事项越多越好，所以这通常是双方谈判的焦点。Term Sheet中的描述如下：</p>

<p>　　The following issuances shall not trigger anti-dilution adjustment: (i) reserved as employee shares described under the Company&rsquo;s option pool, (ii) … (iii) …</p>

<p>　　发行下列股份不引发防稀释调整：(1)公司期权池为员工预留的期权，(2)… (3)…</p>

<p>　　通常的例外情况有（防稀释调整将不包括下列情况下的股份发行）：</p>

<ol>
<li><p>任何债券、认股权、期权、或其他可转换证券在转换和执行时所发行的股份；</p></li>
<li><p>董事会批准的公司合并、收购、或类似的业务事件，用于代替现金支付的股份；</p></li>
<li><p>按照董事会批准的债权融资、设备租赁或不动产租赁协议，给银行、设备出租方发行的或计划发行的股份；</p></li>
<li><p>在股份分拆、股份红利、或任何其他普通股股份分拆时发行的股份；</p></li>
<li><p>按照董事会批准的计划，给公司员工、董事、顾问发行的或计划发行的股份（或期权）；</p></li>
<li><p>持大多数已发行A类优先股的股东放弃其防稀释权利；</p></li>
</ol>


<p>　　需要注意的是最后一条（6），跟上面的“继续参与”条款类似。在有些投资案例中，后续低价融资时，大多数A系列优先股股东放弃其防稀释权利，同意继续投资。可能有少数投资人不打算继续投资下一轮，他们想通过防稀释条款来增加他们转换后的股份比例。那根据这个例外事项，这些少数投资人是不能执行防稀释条款的。这一条会迫使少数投资人继续参与下一轮投资，以便维持股份比例。</p>

<p>　　<strong>（3）降低防稀释条款的不利后果</strong></p>

<p>　　首先，不到迫不得已，企业家永远不要接受完全棘轮条款；其次，要争取一些降低对创业者股份影响的办法，比如：</p>

<ol>
<li><p>设置一个底价，只有后续融资价格低于某个设定价格时，防稀释条款才执行；</p></li>
<li><p>设定在A轮融资后某个时间段之内的低价融资，防稀释条款才执行；</p></li>
<li><p>要求在公司达到设定经营目标时，去掉防稀释条款或对防稀释条款引起的股份稀释进行补偿。</p></li>
<li><p>企业家可能获得的防稀释条款</p></li>
</ol>


<p>　　企业家在跟VC就防稀释条款谈判时，根据双方的谈判能力，公司受投资人追捧的程度、市场及经济状况等等因素，可能得到不同的谈判结果，如下表：
　　</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/企业家在跟VC就防稀释条款谈判时可能得到不同的谈判结果.jpg"></p>

<p>　　本人编制了一个Excel表格帮助企业家模拟在不同的后续融资估值情况下，不同的防稀释条款对转换价格、转换后股份数量及股份比例的影响。</p>

<p>　　Excel表格下载：<a href="http://www.xyzlove.com/Transshipment/Investment/fxtzxy_Term_Sheet_xj/Anti-dilutionCalculation-English.xls">Anti-dilution Calculation （英文版）</a>。</p>

<h3>防稀释条款背后的道理</h3>

<p>　　第一，有了防稀释条款，能够激励公司以更高的价格进行后续融资，否则防稀释条款会损害普通股股东的利益。防稀释条款要求企业家及管理团队对商业计划负责任，并承担因为执行不力而导致的后果。</p>

<p>　　大部分创业者接受这个条款，如果他们对公司的管理不善，导致后续融资价格低于本轮融资的话，他们的股份会被稀释，所以在有些情况下，企业家可能会放弃较低价格的后续融资。</p>

<p>　　第二，投资人如果没有防稀释条款保护，他们可能会被“淘汰”出局。比如，如果没有防稀释条款，企业家可以进行一轮“淘汰”融资（比如$0.01/股，而当前投资人的购买价格是$2/股），使当前的投资人被严重稀释而出局，然后给管理团队授予新期权以拿回公司控制权。</p>

<p>　　另外，VC也可以通过这个条款来保护他们面对市场和经济的萎靡，比如2000年左右的互联网泡沫。</p>

<h3>一个防稀释条款案例</h3>

<p>　　假设某公司已给创始人发行了1,000,000股普通股，给员工发行了200,000股普通股的期权，A轮融资时以$1.00的价格给VC发行了1,000,000股A系列优先股（融资$1M）。B轮融资时，以$0.75的价格发行了1,000,000股B系列优先股（融资$0.75M）。</p>

<p>　　下表给出在广义加权平均、狭义加权平均和棘轮降低三种情况下，A系列优先股股东在B轮融资后的转换价格，以及1,000,000股A系列优先股能够转换成普通股的数量。</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/在广义加权平均、狭义加权平均和棘轮降低三种情况下股份转换数量的差异.jpg"></p>

<p>　　从上表可以看出，不同防稀释条款，导致的股份转换数量的差异，以及对创始人和当前股东的影响。</p>

<h3>总结</h3>

<p>　　防稀释条款通常是精明的投资人为了在后续低价融资时，保护自己利益的一种方式。对创始人来说，防稀释条款通常是融资中的一部分，理解其中的细微差异和了解谈判的要点是创业者很重要的创业技能。</p>

<p>　　尽管偶尔A轮融资的Term Sheet中不包括防稀释条款，但如果有的话，不要试图要求VC去掉防稀释条款，所以在谈判之前多些了解总是有好处的。另外，只要企业家把公司经营好，在融资后为公司创造价值，让防稀释条款不会被激活实施，这比什么都强。
　　
　　</p>

<h2>风险投资协议（Term Sheet）详解之三：董事会</h2>

<blockquote><p>　　企业家在私募融资时关注“董事会”条款，并不是说通过董事会能创造伟大的公司，而是防止组建一个糟糕的董事会，使创始人失去对企业运营的控制。一个合理的董事会应该是保持投资人、企业、创始人以及外部独立董事之间合适的制衡，为企业的所有股东创造财富。</p></blockquote>

<p><img class="center" src="http://epingwang.me/images/2015/07/风险投资协议（Term" title="Sheet）详解之三：董事会.jpg" ></p>

<p>　　VC在投资时，通常会关注两个方面：一是价值，包括投资时的价格和投资后的回报；二是控制，即投资后如何保障投资人自己的利益和监管公司的运营。</p>

<p>　　因此，VC给企业家的投资协议条款清单（Term Sheet）中的条款也就相应地有两个维度的功能：一个维度是“价值功能”，另一维度是“控制功能”。有些条款主要是“经济功能”，比如投资额、估值、清算优先权等，有些条款主要是“控制功能”，比如保护性条款、董事会等。如下图所示：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/Term" title="Sheet中的两个维度：“价值功能”与“控制功能”.jpg" ></p>

<p>　　“董事会”条款无疑是“控制功能”中最重要的条款之一。在创业天堂硅谷流行这么一句话：&#8221;Good boards don&rsquo;t create good companies, but a bad board will kill a company every time.&ldquo;（好的董事会不一定能成就好公司，但一个糟糕的董事会一定能毁掉公司。）</p>

<p>　　Term Sheet中典型的“董事会”条款如下：</p>

<p>　　Board of Directors: The board of the Company will consist of three members, two designated by the Common Shareholders and one of which must be the Company&rsquo;s CEO; and one designated by the Investor.</p>

<p>　　董事会：董事会由3个席位组成，普通股股东指派2名董事，其中1名必须是公司的CEO；投资人指派1名董事。</p>

<p>　　对企业家而言，组建董事会在A轮融资时的重要性甚至超过企业估值部分，因为估值的损失是一时的，而董事会控制权会影响整个企业的生命期。但很多企业家常常没有意识到这一点，而把眼光主要盯在企业估值等条款上。设想一下，如果融资完成后，企业的董事会批准了以下某个决议，企业家／创始人是否会后悔把主要精力放在企业估值的谈判上：</p>

<p>　　开除创始人管理团队，并使其失去了尚未承兑（unvested）的股票；</p>

<p>　　拒绝其他投资人的投资意向，直到公司几乎现金短缺，然后强迫公司以低估值从当前投资人那里募集B轮融资；</p>

<p>　　将公司廉价卖给公司投资人投资过的其他公司。</p>

<p>　　在A轮融资之前，大部分私营公司的创始人／CEO是老板，但融资之后，新组建的董事会将成为公司的新老板。一个好的董事会，即使是在你不同意他们做出的决策的时候，仍然信赖它。
　　</p>

<h3>董事会席位</h3>

<p>　　根据中国<a href="http://www.xyzlove.com/Transshipment/Law/zhrmghggsf/zhrmghggsf.htm">《公司法》</a>规定，有限责任公司至少要有3名董事，而股份制公司则需要5名董事，但这并不是世界范围内通行的版本。在开曼群岛（Cayman Islands）、英属维尔京群岛（BVI）以及美国的许多州（如特拉华州），其法律允许公司只设1名董事。通常来说，董事会席位设置为单数，但并没有法律规定不允许为双数。对A轮融资的公司来说，为了董事会的效率以及后续融资董事会的扩容考虑，理想的董事人数为3～5人。</p>

<p>　　<strong>董事会应该反映出公司的所有权关系</strong></p>

<p>　　董事会代表公司的所有者，负责为公司挑选其管理者——CEO，并确保这位CEO对公司的所有者尽职尽责。当然，糟糕的CEO自然会被淘汰出局。董事会的设立应该反映出公司的所有权关系，比如已经公开发行上市的公司，其董事会构成就是如此。理论上，所有的董事会成员都应服务于公司的利益，而不是仅仅服务于他们自己持有的某种类型的股权。</p>

<p>　　通常A轮融资完成以后，普通股股东（创始人）还拥有公司的绝大部分所有权，普通股股东就应该占有大部分的董事会席位。假设，A轮融资完成以后，普通股股东持有公司大约60%的股份，如果A轮是两个投资人的话，董事会的构成就应该是：</p>

<p>　　3个普通股股东＋2个投资人＝5个董事会成员</p>

<p>　　如果只有1个投资人，那么董事会的构成就应该是：</p>

<p>　　2个普通股股东＋1个投资人＝3个董事会成员</p>

<p>　　不管是以上哪一种情况，普通股东都按简单多数的方式选举出其董事。</p>

<p>　　在融资谈判中，创始人需要明确和坚持两点：</p>

<p>　　一、公司董事会组成应该根据公司的所有权来决定；</p>

<p>　　二、投资人（优先股股东）的利益由Term Sheet中的“保护性条款（Protective Provisions）”来保障。董事会是保障公司全体股东利益，既包括优先股也包括普通股。</p>

<p>　　<strong>设立独立董事席位</strong></p>

<p>　　融资谈判地位有时会决定谈判的结果。如果创业企业质量很好，在A轮融资时投资人会认可这样的董事会安排。但是如果投资人不答应这种董事会结构，而创业者又希望得到他们投资的话，采用下面这个偏向投资人的方案（设立一个独立董事）：</p>

<p>　　2个普通股股东＋2个投资人＋1个独立董事＝5个董事会成员</p>

<p>　　或</p>

<p>　　1个普通股股东＋1个投资人＋1个独立董事＝3个董事会成员</p>

<p>　　偏向投资人方案的董事会给予不同类型股份相同的董事会席位，而不管他们的股份数量（股权比例）。这有点不合道理，但这就是风险投资！</p>

<p>　　如果最终签署的条款是以上方案的话，那么创业者要让投资人同意：在任何时候公司增加1个新投资人席位的时候（比如B轮投资人），也要相应增加1个普通股席位。这样是为了防止B轮融资时，投资人接管了董事会。</p>

<p>　　投资人可能会推荐一个有头有脸的大人物做独立董事，创业者通常是无法拒绝的。但是这个大人物跟VC的交往和业务关系通常会比跟你多，当然他更倾向于维护投资人的利益了。</p>

<p>　　这样，普通股股东（创业者）在董事会上就面临失去主导地位，解决这个困境的最简单办法是在融资之前就设立独立董事。至少也是选择你信任的、有信誉的人来做独立董事。如果融资之前，你无法或没有设立独立董事，谈判是要争取下面的权利：</p>

<p>　　一、独立董事的选择要由董事会一致同意；</p>

<p>　　二、由普通股股东推荐独立董事。</p>

<p>　　<strong>设立CEO席位</strong></p>

<p>　　投资人通常会要求公司的CEO占据一个董事会的普通股席位，这看起来似乎挺合理，因为创始人股东之一在公司融资时通常担任CEO。但创业者一定要小心这个条款，因为公司一旦更换CEO，那新CEO将会在董事会中占一个普通股席位，假如这个新CEO跟投资人是一条心的话，那么这种“CEO＋投资人”的联盟将控制董事会。</p>

<p>　　新的CEO也许是一名职业经理人，通常他与VC合作的机会远比与你们公司合作的机会多。VC通常会向有前景的公司推荐CEO，还会让这名CEO共同参与公司的投资。他们决定公司支付给这个CEO的报酬。你认为CEO会忠诚于谁呢?</p>

<p>　　“CEO＋投资人”联盟可能会给公司、公司创始人和员工都带来伤害，一个硅谷的简单例子可以参考：</p>

<p>　　公司需要募集B轮融资，在投资人授意下，CEO并不积极尽力运作，导致公司无法从其它地方筹措资金。结果，公司只能从当前的投资人那里以很低的价格获得B轮融资；</p>

<p>　　结果是：投资人在公司估值较低的时候注入更多资金，获得更多股份；几个月之后，CEO也按照市场行情获得了“合理数额”的股份。但创始人和员工的股份比例却被稀释了。</p>

<p>　　上面的故事告诉我们，一个新CEO并不一定是你在董事会中的朋友。如果你正打算雇佣一个新的CEO，不妨为他在董事会中设立一个新的席位。</p>

<p>　　例如，对于偏向于投资人的董事会中，投资人已占有2个席位，专门增设1个CEO席位：</p>

<p>　　1个普通股东＋1个投资人＋1个CEO（目前是创始人XXX）＝3个董事会成员</p>

<p>　　1个普通股东＋1个投资人＋1个独立董事＋1个CEO（目前是创始人XXX）＝4个董事会成员</p>

<p>　　董事会中的普通股席位应该永远由普通股股东选举产生。另外，如果你希望董事会的成员数是奇数的话，那就再多加一个独立董事席位。</p>

<p>　　在融资谈判中，创始人需要明确：</p>

<p>　　一、尽管CEO持有的也是普通股，但新的CEO很可能要同投资人结盟，CEO席位会在事实上对投资人更有利；</p>

<p>　　二、CEO并不在董事会中代表普通股股东，他的工作是让公司所有类型的股权增值。</p>

<p>　　<strong>公平的投资后董事会结构</strong></p>

<p>　　目前国内VC的A轮投资Term Sheet中，董事会条款的主流是：“创始人＋创始人及CEO＋A轮投资人”的结构。</p>

<p>　　通常而言，下面的A轮投资后的董事会结构也算公平：</p>

<p>　　1个创始人席位、1个A轮投资人席位及1个由创始人提名董事会一致同意并批准的独立董事。（单一创始人）</p>

<p>　　1个创始人席位（XXX）、1个CEO席位（目前是创始人YYY）、1个A轮投资人席位及1个由CEO提名董事会一致同意并批准的独立董事。（多个创始人）</p>

<h3>总结</h3>

<p>　　企业家在私募融资时关注“董事会”条款，并不是说通过董事会能创造伟大的公司，而是防止组建一个糟糕的董事会，使创始人失去对企业运营的控制。一个合理的董事会应该是保持投资人、企业、创始人以及外部独立董事之间合适的制衡，为企业的所有股东创造财富。</p>

<h2>风险投资协议（Term Sheet）详解之四：保护性条款</h2>

<blockquote><p>　　设立保护性条款目的是保护投资人小股东，防止其利益受到大股东侵害。但投资人对保护性条款的行使，会对公司的正常运营产生一定的干扰，创业者在这个条款的谈判是要考虑如何在这两者之间找到一个适当的平衡。</p></blockquote>

<p><img class="center" src="http://epingwang.me/images/2015/07/风险投资协议（Term" title="Sheet）详解之四：保护性条款.jpg" ></p>

<p>　　保护性条款（Protective Provisions），顾名思义，就是投资人为了保护自己的利益而设置的条款，这个条款要求公司在执行某些潜在可能损害投资人利益的事件之前，要获得投资人的批准。实际上就是给予投资人一个对公司某些特定事件的否决权。</p>

<h3>投资人为什么要保护性条款</h3>

<p>　　也许你会认为投资人通过派代表进入董事会，对公司就有足够的控制，保证公司不会从事任何违背其利益的事情，投资人没有必要太关注保护性条款。</p>

<p>　　这种看法是不对的，因为作为董事会成员，投资人代表的法律职责是为公司的利益最大化而工作。有时候，公司的利益与某特定类别股份（比如A类优先股）的利益是不一致的，这时就会出现这样一种情况：作为董事，他在法律上应该为了公司的整体利益同意某件事，而作为某类股份的股东，需要通过其他渠道来保护自己的利益。</p>

<p>　　A轮融资后投资人持有的优先股通常占公司股份比例为20%-40%，如果普通股股东联合起来，他们可以控制公司的股东会和董事会：</p>

<ul>
<li><p>优先股无法影响股东投票，因为他们的股份不够；</p></li>
<li><p>优先股也无法影响董事会投票，因为他们的席位不够。（比如，董事会组成是2个普通股席位、1个优先股席位、无独立董事席位）。</p></li>
</ul>


<p>　　投资人需要通过保护性条款，至少要防止普通股股东（比如创始人）做以下事情：</p>

<ul>
<li><p>将公司以$1美元价格卖给创始人的亲属，将优先股扫地出门；</p></li>
<li><p>创始人以$1亿美元价格将部分股份卖给公司，立刻过上优哉游哉的好日子；</p></li>
<li><p>发行巨量股份给创始人，将优先股比例稀释成接近零。
　　</p>

<h3>典型优先股保护性条款</h3></li>
</ul>


<p>　　Term Sheet中典型的优先股保护性条款（中／英文条款对照）如下：</p>

<p>　　Protective Provisions: So long as any of the Preferred is outstanding, consent of the holders of at least 50% of the Preferred will be required for any action that:</p>

<p>　　(i) amends, alters, or repeals any provision of the Certificate of Incorporation or Bylaws in a manner adverse to the Series A Preferred;</p>

<p>　　(ii) changes the authorized number of shares of Common or Preferred Stock;</p>

<p>　　(iii) authorizes or creates any new series of shares having rights, preferences or privileges senior to or on a parity with the Series A Preferred;</p>

<p>　　(iv) approves any merger, sale of assets or other corporate reorganization or acquisition;</p>

<p>　　(v) purchases or redeems any common stock of the Company (other than pursuant to stock restriction agreements approved by the board upon termination of a consultant, director or employee);</p>

<p>　　(vi) declares or pays any dividend on any shares of Common or Preferred Stock;</p>

<p>　　(vii) approves the liquidation or dissolution of the Company;</p>

<p>　　保护性条款：只要有任何优先股仍发行在外流通，以下事件需要至少持有50%优先股的股东同意：</p>

<p>　　(i) 修订、改变、或废除公司注册证明或公司章程中的任何条款对A类优先股产生不利影响；</p>

<p>　　(ii) 变更法定普通股或优先股股本；</p>

<p>　　(iii) 设立或批准设立任何拥有高于或等同于A类优先股的权利、优先权或特许权的其他股份；</p>

<p>　　(iv) 批准任何合并、资产出售或其他公司重组或收购；</p>

<p>　　(v) 回购或赎回公司任何普通股（不包括董事会批准的根据股份限制协议，在顾问、董事或员工终止服务时的回购）</p>

<p>　　(vi) 宣布或支付给普通股或优先股股利；</p>

<p>　　(vii) 批准公司清算或解散；</p>

<p>　　这些保护性条款的数量有多有少，少则3、4条，多则二十多条。我认为以上条款是公平及标准的，而其他没有列出的条款是对投资人有利的，而且通常不是风险投资的典型条款。
　　</p>

<h3>谈判要点及谈判空间</h3>

<p>　　跟Term Sheet所有其他条款一样，保护性条款的谈判结果，也是根据企业及投资人双方的谈判地位决定，谁强势，谁就获得有利的条款。</p>

<p>　　保护性条款通常是Term Sheet谈判的焦点，创业者当然希望保护性条款越少越好，最好没有；而VC刚好相反，希望对公司的一系列事件拥有否决权级别的控制。有没有这个权利是个问题，而行不行使是另外一个问题。
　　</p>

<h4>1. 保护性条款的数量</h4>

<p>　　如上文罗列，投资人在保护性条款中会要求对公司的一系列事件拥有批准的权利。创业者跟投资人谈判的最直接目标就是减少这些事件的数量，而不是试图取消保护性条款。</p>

<p>　　因为公司的重大事项都会通过董事会来决策，董事会保障公司的利益。投资人的保护性条款其实是防止发生有利公司但可能危害投资人利益的事件，这类事件包括几类：</p>

<ul>
<li><p>可能改变优先股权利和地位的（如上文i、iii）；</p></li>
<li><p>可能改变优先股股权比例的（如上文ii、v）；</p></li>
<li><p>可能改变优先股退出回报的（如上文iv、vi、vii）。</p></li>
</ul>


<p>　　这些事件都是与投资人的利益直接、紧密相关的，其他事件都是可以通过谈判，排除在保护性条款之外。通常而言，上文的7个条款是比较标准和容易接受的。</p>

<p>　　另外，如果投资人强势，要求对更多事件拥有批准权利，创业者也有其他处理办法，比如：</p>

<ol>
<li><p>要求公司运营达到阶段性里程碑之后，去除某些保护性条款；</p></li>
<li><p>把投资人要求的某些保护性条款变成“董事会级别”，批准权由投资人的董事会代表在董事会决议时行使，而不由投资人的优先股投票。</p></li>
</ol>


<h4>2. 条款生效的最低股份要求</h4>

<p>　　公司应该要求在外流通（outstanding）的优先股要达到一个最低数量或比例，保护性条款才能生效。是“只要有任何数量的优先股在外流通”就生效，还是“超过X%的A类优先股在外流通”才生效。</p>

<p>　　很多保护性条款中要么明确，要么隐含地要求只要有“任何数量”的优先股在外流通，保护性条款都有效。这是有问题的，比如，如果因为回购或转换成普通股，优先股只有1股在外流通，这1股优先股的持有人不应该拥有阻止公司进行某些特定事项的权利。</p>

<p>　　通常而言，这个生效比例越高对创业者越有利。我看到比较多的是25%-75%，50%好像没有什么争议，双方应该都是可以接受的。</p>

<h4>3. 投票比例下限</h4>

<p>　　保护性条款实施时，“同意”票的比例通常设为“多数”或“超过50%”，即公司要执行保护性条款约定的事项之前，要获得持有多数或超过50%优先股的股东同意。在很多情况下，这个比例被设置的更高，比如2/3，尤其是公司有多个投资人的时候（A轮联合投资，或公司经过多轮融资），要保证多数投资人支持公司执行的某个行为。</p>

<p>　　通常而言，这个投票比例的门槛越低对创业者越有利。如果太高，创业者就要当心股份比例小的投资人（small investors）不适当地行使否决权。比如，条款要求90%优先股同意，而不是多数（50.1%）同意，那么一个只持有10.1%优先股的投资人就可以实际控制保护性条款了，他否决就相当于全体优先股股东否决了。</p>

<h4>4. 不同类别的保护条款</h4>

<p>　　当进行后续融资时，比如B轮，通常会讨论保护性条款如何实施。有2种情况：（a）B类优先股获得自己的保护性条款；或（b）B类优先股与A类优先股拥有同一份保护性条款，并一同投票。</p>

<p>　　创业者（公司）当然不希望不同类别的投资人各自拥有单独的保护性条款，而希望所有投资人采用同一份保护性条款，所有投资人一起投票（情况b）。因为A、B类优先股的保护性条款分开的话，公司做任何保护条款中的事情，需要面对2个潜在的否决表决。如果是A轮投资人继续投资B轮，那就没有什么好说的，自然是选择（b）。</p>

<h3>防止投资人谋求自己利益</h3>

<p>　　保护性条款是防止普通股大股东损害优先股小股东，但是它不是牺牲公司利益为优先股谋求利益的工具，创始人要防止优先股股东运用保护性条款谋求自己的利益。</p>

<p>　　比如，公司收到一个收购意向，创业者及管理团队认为卖掉公司对股东有利，董事会同意并批准了。但如果投资人的其他投资案例都不太好，指望这个公司通过IPO或后续可能更好的并购价格让他赚得盆满钵满，投资人就不愿意现在出售。于是，投资人在董事会投票赞成出售，通过行使保护性条款否决出售。</p>

<p>　　其实企业宁愿要一个“自私”的投资人，他通过其董事会席位为自己谋利益，而不希望投资人通过保护性条款做除了保护自己之外的任何事。至少，这个“自私”的投资人作为董事会成员的能力与其董事会席位数量成比例，而保护性条款，给予他一个跟他的股份比例及董事会席位安排完全无关的一个“一票否决权”。
　　</p>

<h3>总结</h3>

<p>　　投资人以小股东的方式投资，要求保护性条款是合理的，也是非常正常的，设立保护性条款目的是保护投资人小股东，防止其利益受到大股东侵害。但投资人对保护性条款的行使，会对公司的正常运营产生一定的干扰，创业者在这个条款的谈判是要考虑如何在这两者之间找到一个适当的平衡。</p>

<p>　　（参考资料：NVCA, Feld Thought, Venture Hacks, A VC, Ask the VC）</p>

<h2>风险投资协议（Term Sheet）详解之五：股份兑现</h2>

<blockquote><p>　　创业是一个艰苦的长期过程，没有一个团队是永远的，创始人应当将兑现条款看作是一个整体协调工具：对VC、共同创始人、早期员工以及后续员工。</p></blockquote>

<p><img class="center" src="http://epingwang.me/images/2015/07/风险投资协议（Term" title="Sheet）详解之五：股份兑现.jpg" ></p>

<p>　　VC在决定是否投资一个公司时，通常最看重的是管理团队。一方面是管理团队的背景和经验，另一方面是保持团队的稳定和持续性。对于背景和经验，可以通过前期的尽职调查（Due Diligence）得到核实，而兑现条款（Vesting）则是保证团队的稳定性的一个有效手段。</p>

<p>　　兑现的概念其实并不复杂，一般来说，投资人都希望创始人和管理团队的股份及期权都要4年时间才完全兑现，就是说你必须待满4年才能拿到你所有的股份或期权。如果你提前离开公司，根据约定的兑现公式，你只能拿到部分股份或期权。</p>

<p>　　兑现条款对国内很多尚未融资的民营企业家来说，不是很容易理解。主要原因是他们的企业都是有限责任公司，按照国内公司法，他们都不存在兑现问题，因为压根就没有股票和期权，创始人一开始就拥有了按照出资额对应的公司股权比例。但外资VC在以离岸公司的模式投资时，离岸公司在股份发行和期权授予方面的灵活性，就满足了VC对创始人和管理团队的控制。
　　</p>

<h3>什么是兑现条款</h3>

<p>　　投资协议中典型的兑现条款如下：</p>

<blockquote><p>　　Vesting: All stock and stock equivalents issued after the Closing to employees, directors, consultants and other service providers will be subject to vesting provisions below unless different vesting is approved by the majority consent of the Board of Directors: 25% to vest at the end of the first year following such issuance, with the remaining 75% to vest monthly over the next three years. The repurchase option shall provide that upon termination of the employment of the shareholder, with or without cause, the Company retains the option to repurchase at the lower of cost or the current fair market value any unvested shares held by such shareholder.</p>

<p>　　The outstanding Common Stock currently held by XXX and YYY will be subject to similar vesting terms provided that the Founders shall be credited with [one year] of vesting as of the Closing, with their remaining unvested shares to vest monthly over three years.</p></blockquote>

<p>　　<strong>股份兑现</strong>：在交割之后发行给员工、董事、顾问等的所有股份及股份等价物将遵从以下兑现条款：发行后的第一年末兑现25%，剩余的75%在其后3年按月等比例兑现。公司有权在股东离职（无论个人原因或公司原因）时回购其尚未兑现的股份，回购价格是成本价和当前市价的低者。</p>

<p>　　由创始人XXX和YYY持有的已发行流通的普通股也要遵从类似的兑现条款：创始人在交割时可以兑现其股份的25%，其余股份在其后3年内按月兑现。</p>

<p>　　对于早期公司，VC通常是要求4年的兑现期，其中第1年为“阶梯（Cliff）”兑现，其余3年每月兑现，到第4年末，全部兑现。如下图：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/第1年为“阶梯（Cliff）”兑现，其余3年每月兑现.jpg"></p>

<p>　　上图的意思就是：如果你在1年之内离开公司，你兑现不了任何股份。1年之后，你可以兑现25%的股份（这就是“阶梯”），然后你开始按月在剩余的年限里（3年）兑现剩余股份。比如你在投资交割1年半之后离开公司，你可以兑现你所有股份的37.5%（25%+75%*6/36）。</p>

<p>　　股份持有人在离开公司后，他那些还没有兑现的股份通常由公司收回注销，这些股份不会重新分配，所有其他留守的股东都被反向稀释而增加股权比例，比如VC、普通股东、期权持有人。对于没有兑现的期权，公司收回至期权池，可以继续分配给后续员工。</p>

<p>　　很多创业者不理解：为什么原来属于我的股份，VC一旦投资进来，这些股份就需要几年时间才能拿回来，这些股份本来就是我的啊！</p>

<p>　　对于兑现条款，创业者要了解以下几点：</p>

<ol>
<li><p>你的股份一开始就都是你的，在行使股东投票表决的时候，你可以按照所有股份都已兑现的数量投票。比如投资交割时创始人的股权比例是70%（1000万股），则在你离开公司之前的任何时候，都有1000万股股票的投票权；</p></li>
<li><p>你在公司工作满4年之前，可以自由处置（如：出售）的股份数量不是全部，而是按照上述兑现条款约定已经兑现的数量。比如上述的1000万股，创始人在投资交割后1年半的时候，可以自由处置的数量是375万股；</p></li>
<li><p>兑现条款在VC投资之后，可以通过董事会修改，以应对不同的情况；</p></li>
<li><p>拒绝兑现条款会让投资人非常担心你离开公司，而这对于他们决定是否投资非常重要；</p></li>
<li><p>兑现条款对VC有好处，对创始人也有好处。如果公司有多个创始人，VC投资后某个创始人要求离开，如果没有股份兑现条款，离开的创始人将拿走他自己全部股份，而VC和留下来的创始人将要为他打工。如果有股份兑现条款，所有创始人都会努力工作以拿到属于自己的股份。同样道理，员工的股权激励也需要通过兑现条款的方式逐步获得。</p></li>
</ol>


<h3>谈判要点</h3>

<p>　　创始人要明白一个事实，随着时间推移，你对公司的贡献会相对越来越不重要，但是你每月兑现的股份数量却相对比较大。创始人通常在公司早期对公司的贡献最大，但是股份兑现在3、4年内都是平均的。一旦你对公司的贡献相对减小，公司的任何人都有让你离开的动机，同时取消你尚未兑现股份。所以，一旦VC发觉你在公司存在的价值与你尚未兑现的股份不匹配的时候，你就麻烦了。比如，VC在第2年发现你对于公司而言，没有太多价值了，而你还有超过50%的股份尚未兑现，那VC最理性的做法就是：开除你，回购你的股份。所以，创始人要有所准备。</p>

<p>　　第一、通常，公司回购未兑现的股份会被注消，这样的反向稀释会让创始人、员工和VC按比例受益。创始人可以要求公司不注销回购的股份，而将这些股份在创始人和员工之间按持股比例分配。这样要求的原因是离开公司的创始人所持有的尚未兑现股份是VC投资之前创造的，应该分配给创造这些价值的创始人和员工，而不是VC。当然，也可以将回购的股份放入期权池作为取代者的期权。</p>

<p>　　第二、争取最短的兑现期。考虑到创始人已经在公司工作了1年或更长时间，这些工作时间可以要求投资人给予适当的补偿。比如创始人可以要求在投资交割时，就获得其1年的兑现股份（25%），在未来3年兑现剩余股份。如下图：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/创始人可以要求在投资交割时，就获得其1年的兑现股份.jpg"></p>

<p>　　第三、创始人要争取在特定事件下有加速兑现的权利。比如，达到某个经营里程碑指标时，获得额外的股份兑现；被董事会解职时，获得额外的股份兑现。额外兑现的股份数量通常是原定1年的兑现量，有时甚至是全部尚未兑现的股份。比如在经过2年，由于达到业绩目标，按事先的约定，你有权获得1年额外的股份兑现，则股份兑现如下图：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/创始人要争取在特定事件下有加速兑现的权利.jpg"></p>

<p>　　第四、如果公司在被投资之后，股份兑现期还没有结束就IPO了，那创始人自然拿到全部股份，这样也是VC所期望的。但是在目前的市场环境下，典型的早期公司需要5到7年才可能IPO退出，大部分的退出方式是被并购。通常来说，创始人在面临公司被并购时，会要求加速兑现股份。处理方式有两种：一是“单激发（Single trigger）”，即在并购发生时自动加速兑现；二是“双激发（Double trigger）”，即加速兑现需要满足2个条件（比如，公司被并购及创始人在新公司不再任职）。</p>

<p>　　目前比较常见的加速兑现是“单激发”额外兑现25%-50%的股份，“双激发”额外兑现50%-100%的股份。加速兑现不缩短兑现期，而只增加兑现股份数量，减少未兑现股份数量。相对而言，“双激发”应用得更普遍一些，而“双激发”中的另外一个激发因素（如创始人在新公司不再任职）也是可以谈判定义的。比如被无理由开除，或者创始人因合适理由离职。恰当的开除理由包括故意过失、重大过失、欺诈行为、违反合约等；合适的离职理由包括职位变更、薪酬降低、住址变远等。</p>

<p>　　具体的条款如下：</p>

<p>　　In the event of a merger, consolidation, sale of assets or other change of control of the Company and should an Employee be terminated without cause within one year after such event, such person shall be entitled to [one year] of additional vesting. Other than the foregoing, there shall be no accelerated vesting in any event.</p>

<p>　　在发生被兼并、合并、资产出售或其他改变公司控制权事件，并且员工在此事件后1年内被无故解雇，被解雇员工将有权获得1年额外的股份兑现。除此之外，任何情况下没有加速兑现。</p>

<p>　　创始人当然希望在并购交易时加速拿到全部股份，因为对方可能是长期的竞争对手，在新公司再工作几年来兑现所有股份可不是件愉快的事情。而VC则不希望加速兑现影响交易的进行，因为并购方通常也希望对创始人、团队、员工保持某些持续的激励，因此他们有时候不愿意让所有股份兑现，或者他们重新设置新的股份兑现计划作为交易的一部分。</p>

<h3>股份兑现的应用实例</h3>

<p>　　公司发行5,000,000股，创始人甲、乙两人各持有2,000,000股，VC持有1,000,000股，股权比例分别为40%，40%，20%。其中，两位创始人股份的20%（即400,000股）在公司设立时就兑现，公司以后不能回购。剩下80%（即1,600,000股），分四年按月兑现（每年20%，400,000股）。</p>

<p>　　在VC投资后的第一年期间，尽管甲、乙两位创始人已兑现的股份只有400,000股，但仍然拥有全部股份（公司的40%比例，2,000,000股）的投票权。</p>

<p>　　如果甲在一年后离开的话，他会拿到1年兑现的20%，即400,000股，加上创始时拿到的400,000股，共800,000。甲剩下未兑现的1,200,000被公司以象征性价格回购注销。公司总股份量变为3,800,000。甲占有800,000÷3,800,000＝21%；乙占有2,000,000÷3,800,000＝53%；VC占有1,000,000÷3,800,000＝26%。</p>

<p>　　如果没有兑现条款约束的话，甲离开时会与乙及VC有很大的争执。甲会要求拿到自己全部的2,000,000股，而乙和VC当然会反对，他们当然不愿意为甲打工。</p>

<p>　　如果一年以后，乙的贡献或重要性比甲多，而最初甲、乙的股份分配是相同的。公司可以召开董事会，VC、甲、乙一起商量，把甲、乙双方还没有兑现的股份重新分配。甲、乙都会比较容易接受，因为已经兑现的股份不变。而且如果一方不接受的话，离开公司，也有一份明确公平的已经兑现的股份。
　　</p>

<h3>总结</h3>

<p>　　尽管股份兑现条款常常是创始人和VC谈判的热门话题，但这个条款其实对于双方都是有某种程度的好处。它是一个很公平的方法，因为创业是一个艰苦的长期过程，没有一个团队是永远的，创始人应当将兑现条款看作是一个整体协调工具：对VC、共同创始人、早期员工以及后续员工。
　　
　　（参考：<a href="www.feld.com/blog">www.feld.com/blog</a>, <a href="www.shaoblog.com">www.shaoblog.com</a>）
　　　　</p>

<h2>风险投资协议（Term Sheet）详解之六：股份回购</h2>

<blockquote><p>　　股份回购权（Redemption Right）就是VC在特定的条件下，可以要求公司购买他们持有的股票。根据调查，从2005年至2007年的VC投资案例中，超过1/3的案例包含股份回购条款。</p></blockquote>

<p><img class="center" src="http://epingwang.me/images/2015/07/风险投资协议（Term" title="Sheet）详解之六：股份回购.jpg" ></p>

<p>　　风险投资最终一定要实现对投资项目的退出，并尽力获得理想的资本套现，以便能给风险投资基金的投资人要求的回报。通常而言，风险投资的退出渠道一般有五种：①首次公开发行（IPO）；②公司被并购（acquisition）；③股份出售（trade sale）；④股份回购（redemption）；⑤公司清算（liquidation）。</p>

<p>　　IPO当然是皆大欢喜的情况，VC可以在公开市场出售股份实现资本套现退出。公司并购、股份出售及公司清算都应该算作是变现事件（liquidation event），在这些情况下，VC通过清算优先权（liquidation preference）条款来约定退出回报方式。除此之外，如果公司发展得波澜不惊，没有发生变现事件，那VC如何实现退出，这就需要股份回购条款了。</p>

<h3>什么是股份回购权</h3>

<p>　　股份回购权（Redemption Right）就是VC在特定的条件下，可以要求公司购买他们持有的股票。根据调查，从2005年至2007年的VC投资案例中，超过1/3的案例包含股份回购条款。</p>

<p>　　通常，VC给出的股份回购权条款如下：</p>

<p>　　Redemption: At the election of the holders of at least majority of the Series A Preferred, the Company shall redeem the outstanding Series A Preferred in three annual installments beginning on the [fifth] anniversary of the Closing. Such redemptions shall be at a purchase price equal to the Original Purchase Price plus declared and unpaid dividends.</p>

<p>　　回购：如果大多数A类优先股股东同意，公司应该从第5年开始，分3年回购已发行在外的A类优先股，回购价格等于原始购买价格加上已宣布但尚未支付的红利。</p>

<p>　　尽管股份回购权是VC投资协议中很重要的一个条款，但在实际操作中，股份回购权几乎从来不会、也没有被执行。但股份回购权是有其存在的道理，并且对VC是有很大帮助的。</p>

<p>　　首先，VC会担心被投资的公司发展到“活死人（Walking Dead）”状态，就是能够产生一定的收入，维持公司运营，但是却无法成长到让其他公司有收购的兴趣，或是上市。这种情况下，通过股份回购权，投资人获得一条有保障的退出渠道。但是，通常而言，如果公司既达不到上市的标准，也没有被并购的吸引力，公司也不会留存有足够的现金来回购VC的股份。</p>

<p>　　第二，风险投资基金有生命周期，通常的基金运作周期是10年左右。而他们大部分的投资是在前4年进行，所以，VC通常要求在投资后5-7年左右变现，这样他们的投资项目才能在基金生命周期内回收资金，对基金经理来说，要求股份回购权才能保障基金在清盘时有变现渠道。</p>

<p>　　第三、通过这个条款，让被投资企业的经营者有更多的责任和压力，考虑如何善用投资和经营企业。</p>

<p>　　除了上述的股份回购权条款之外，目前还有一种比较苛刻的回购权形式——经营不善回购（Adverse Change Redemption），如下：</p>

<p>　　Adverse Change Redemption: Should the Company experience a material adverse change to its prospects, business or financial position, the holders of at least majority of the Series A Preferred shall have the option to commit the Company to immediately redeem the outstanding Series A Preferred. Such redemption shall be at a purchase price equal to the Original Purchase Price plus declared and unpaid dividends.</p>

<p>　　<strong>经营不善回购</strong>：如果公司的前景、业务或财务状况发生重大不利变化，多数A类优先股股东同意时，有权要求公司立刻回购已发行在外的A类优先股。购买价格等于原始购买价格加上已宣布但尚未支付的红利。</p>

<p>　　这个条款非常模糊，对公司非常有惩罚性，并且给予投资人基于主观判断的控制权，理性的投资人不会要求这样的回购权条款，理性的企业家更不应该接受这样的条款。</p>

<h3>股份回购条款的谈判</h3>

<p>　　企业家与VC进行谈判时，最好的结果当然是取消股份回购条款了。但通常情况下，VC是会要求股份回购权的，谈判内容主要有以下几点：</p>

<p>　　第一、VC行使权利的时间。大部分的回购权要求至少在A轮融资5年之后才允许行使。这是因为VC要给予公司足够的时间发展以达到目标，VC基金也需要在基金生命周期结束前变现其投资。所以，企业家在跟VC谈判之前，就要了解其基金的成立时间及到期时间。如果10年期的基金，第6年的时候投资，就不可能要求融资后5年行使回购权；如果是新成立的基金，则可以要求更长的期限。</p>

<p>　　第二、回购及支付方式。通常由于企业的支付能力有限，VC会接受分期回购的方式。当然期限越长对企业的压力越小，一般来说3年或4年是比较合适的。回购权可以允许部分投资人选择不要求公司回购或者要求所有股份都必须被回购。另外，不同阶段的投资人，其股份的回购次序不应有先后之分。</p>

<p>　　第三、回购价格。回购价格通常是初始购买价格加上未支付的股利，如果VC比较强势，可能会要求一定的投资回报率，比如10%的年回报率，或者是初始购买价格的2倍。
　　
　　第四、回购权激发方式。回购权通常由多数（>50%）或大多数（>2/3）投资人投票同意时才实施，当然也可以约定在某个时间点自动生效。当然需要越多的投资人同意才能要求公司回购股份对企业家更有利。</p>

<h3>VC对回购权的控制</h3>

<p>　　VC和企业家往往通过两种方式控制公司：一是董事会席位和投票权；二是协议赋予的权利。虽然董事会控制权和多数投票权是控制退出的最有效的方式，但VC在第一轮投资时，通常不会拥有多数投票权和董事会席位，那么不能通过这种方式来行使退出决策权时，就只能借助于股份回购权等合同约定控制权（contractual rights）了。</p>

<p>　　但是如果在VC要求公司回购其股份时，公司没有足够的支付资金，回购权对VC而言就不是一个可行的变现手段。这种情况下，VC可能会强迫管理团队接受他们的退出要求，并可能导致企业家被迫出售公司。另外，在公司无法支付时，VC也可能会要求获得额外的董事会席位，导致VC获得董事会控制权，从而调整公司运营方向或直接出售公司。</p>

<h3>主动回购</h3>

<p>　　通常认为股份回购条款是对风险投资方有利，对企业家不利的条款，在某些银行和会计师看来，这种拥有回购权的优先股（Redeemable Preferred Share, RPS）投资更类似于一种企业负债，而不是投资；而且，在企业缺乏资金而使得回购权难以行使的情况下，企业后续的融资将变得很困难，新的投资者必然会将以前投资方的股份回购权作为一项重要的谈判内容进行考虑。</p>

<p>　　当然，企业家首先是尽量不接受这个条款，如果必须接受，也应采取上述的谈判方法，降低回购对公司的影响。另外，前面讲到的都是在企业发展无法达到预期，由VC预设时间，自动或强制要求企业回购其股份的模式，此时企业处于被动状态。相对应的，如果企业家对企业经营有良好预期的话，也可以约定在适当时候企业（企业家）有权强制回购投资方的股权。这种要求主动回购VC股份的模式，本人只在很多<a href="http://www.xyzlove.com/CompilationInvestment-BusinessPlan.htm">商业计划书</a>里面看到，在实际的投资条款里倒是从没见过。</p>

<p>　　另外，企业家也可以约定在某种特定的情况下，企业（企业家）有权回购投资人的股份。比如投资人又投资了企业的竞争对手、投资人被竞争对手收购等等。前段时间Microsoft欲收购Yahoo!威胁到<a href="http://www.xyzlove.com/CompilationMarket-Alibaba.htm">阿里巴巴</a>就是一例。Yahoo!公司在2005年9月以10亿美元加上其中国子公司——<a href="http://www.xyzlove.com/Transshipment/Merger/yh_ry_tb_albb/yh_ry_tb_albb.htm">Yahoo!中国收购阿里巴巴39%的股权</a>，在购买协议中就约定，如果Yahoo!被其他企业收购并导致Yahoo!持有的阿里巴巴股权控制权将发生转移，阿里巴巴拥有对Yahoo!持有股份的回购权。这是因为阿里巴巴管理层担心，一家规模更大的公司（比如Microsoft），一旦收购Yahoo!可能会插手阿里巴巴的经营管理，而马云等本土管理层认为保持独立性和控制权对于阿里巴巴非常重]要。
　　　　</p>

<h3>总结</h3>

<p>　　股份回购权只不过是VC保障自己退出的一个手段，企业家应该给予理解，但要尽量提高回购权行使的门槛，降低行使回购权对企业经营的影响。另外，也可以通过主动回购权的方式，维护企业的利益。</p>

<h2>风险投资协议（Term Sheet）详解之七：领售权</h2>

<blockquote><p>　　领售权，就是指VC强制公司原有股东参与投资者发起的公司出售行为的权利，VC有权强制公司的原有股东（主要是指创始人和管理团队）和自己一起向第三方转让股份。</p></blockquote>

<p><img class="center" src="http://epingwang.me/images/2015/07/风险投资协议（Term" title="Sheet）详解之七：领售权.jpg" ></p>

<p>　　VC的退出渠道之一是投资的企业被并购（M&amp;A），通过将企业出售给第三方，VC可以将自己的股份变现。但是，VC通过自己所谓的增值服务，千方百计找到一个合适的并购方之后，创始人或管理团队可能并不认同并购方、并购方的报价、并购条款等，导致并购交易难以进行，这个时候，VC可能会搬出一个杀手锏——领售权（Drag-Along Right），强迫创始人接受交易。</p>

<h3>什么是领售权条款</h3>

<p>　　领售权，就是指VC强制公司原有股东参与投资者发起的公司出售行为的权利，VC有权强制公司的原有股东（主要是指创始人和管理团队）和自己一起向第三方转让股份，原有股东必须依VC与第三方达成的转让价格和条件，参与到VC与第三方的股权交易中来。通常是在有人愿意收购，而某些原有股东不愿意出售时运用，这个条款使得VC可以强制出售。如下图所示：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/领售权，就是指VC强制公司原有股东参与投资者发起的公司出售行为的权利.jpg"></p>

<p>　　VC投资协议中，典型的领售权条款如下：</p>

<p>　　Drag-Along Right: Prior to a Qualified Public Offering, if a majority of the holders of Series A Preferred Shares agree to sale or liquidation of the Company, the holders of the remaining Series A Preferred Share and Common Share shall, if applicable, be required to approve such transactions and, if applicable, to sell their shares at the same price and upon the same terms and conditions.</p>

<p>　　<strong>领售权</strong>：在合格IPO之前，如果多数A类优先股股东同意出售或清算公司，剩余的A类优先股股东和普通股股东应该同意此交易，并以同样的价格和条件出售他们的股份。</p>

<p>　　领售权条款的设计有这样几个目的：</p>

<p>　　首先，如果一个公司的绝大多数股东决定出售公司，几个小股东不应该阻止这桩交易，也不应该有办法阻止。有些公司初创时有很多创始人、天使投资人，过了几年在公司可以被出售的时候，要想把所有的这些原始股东聚集在一起不是一件容易的事，当然也可能有些公司经营过程中产生矛盾的小股东故意不出席，阻挠和要挟公司，这个时候，领售权就可以起作用了。只要大多数股东同意将公司出售，这些小股东是不可以、也没有办法阻止这个交易的。</p>

<p>　　其次，通常在收购企业时，收购方会购买目标公司全部或大多数的股权，如果股权比例太低，就失去收购的价值了。所以，如果有合适的并购方出现，VC这样的小股东手中持有的股份比例是不够的。当然可以由董事会来通过出售公司的决议，但这是没有保障的，董事会上VC的投票权往往没有决定性。</p>

<p>　　第三，依据“清算优先权（Liquidation Preference）”条款，公司如果出现出售或清算等事件，VC要按照设定方式获得优先分配资金（优先分配额）。如果VC发起的公司出售交易金额低于投资者的优先分配额，创始人和管理团队一定会反对的，因为他们什么也得不到。即使是交易金额超出优先分配额，创始人和管理团队也可能会不满意分配的资金，从而反对此交易。</p>

<p>　　以上几点决定了，如果VC想通过出售公司实现退出，领售权就是很好的底牌。</p>

<p>　　但是，领售权如果被VC设计得对他们有利，则会给VC小股东一个极大的权力，把创始人（通常是大股东）拖进一个可能不利的交易中。如上所示的条款，“多数A类优先股股东同意”就可以代表剩余的其他所有股东同意这个出售交易，A类优先股通常是公司的少数股权，其中的多数更是少数，但领售权给投资者在出售公司时，有绝对的控制权，即使投资者的股份只占公司的极小部分。</p>

<h3>领售权的谈判</h3>

<p>　　创始人和天使投资人可能会对领售权有很多意见，首先就觉得“不公平”——我要按我自己的意志、为自己的利益投票，为什么要受VC强迫？但是记住这个条款是融资谈判中众多条款之一，自然有谈判的空间，没有什么标准条款。如果VC不接受，就放弃。</p>

<p>　　领售权通常的谈判要点如下：</p>

<p>　　第一、受领售权制约的股东。通常，VC希望持有公司大部分股份的普通股股东签领售权，领投的VC通常也希望其他跟投的VC也签署，这样保证VC不会遇到原始股东和投资人内部对交易产生障碍。其实，对于创始人和管理团队等普通股股东而言，有时候也需要领售权条款！尽管公司出售不需要全体股东一致同意（通常是完全稀释条件下，每类股份的多数或全部股份的多数），但大多数收购方还是希望看到80%、90%的股东同意。因此，如果公司有很多持股比例很少的普通股股东（创始人、天使、团队等），跟所有股东签署领售权协议，其实也是有必要的。</p>

<p>　　第二、领售权激发的条件。通常VC要求的激发条件是由某个特定比例的股东要求（比如50%或2/3的A类优先股，或某特定类别优先股）。</p>

<p>　　对创始人而言就不公平了，因为优先股的多数对公司整体而言，还是少数，所以，创始人可以也要求在领售权激发还需要满足另外一个条件，就是董事会通过，这样对公司所有股东而言就公平了。当然，对于优先股要求通过的比例越高越好，这样优先股股东的多数意见得到考虑。比如上文所示的条款可以改为：</p>

<p>　　<strong>领售权</strong>：在合格IPO之前，如果超过2/3的A类优先股股东及董事会同意出售或清算公司，剩余的A类优先股股东和普通股股东应该同意此交易，并以同样的价格和条件出售他们的股份。</p>

<p>　　第三、出售的最低价格。根据清算优先权，有些股东（尤其是普通股和低级优先股）在公司被收购的时候什么也拿不到。强迫这些股东投票同意这种交易是会面临他们的反对的。所以，有些股东就需要在谈判时要求一个最低的价格之上适用领售权。比如，如果VC在“清算优先权”条款中要求的是“参与清算优先权，2倍回报、3倍上限”时，那普通股股东会认为：</p>

<p>　　（1）只有出售时公司估值高于VC投资额的2倍时，普通股股东才有剩余；</p>

<p>　　（2）只有每股价格达到VC投资价格的3倍时，VC才会转换成普通股，大家按股份比例分配，股东间的利益才能保持相对一致。</p>

<p>　　第四、支付手段。当然现金是最好的，另外，上市公司的可自由交易的股票也可以接受。如果并购方是非上市公司，以自己的股份或其他非上市公司股份作为支付手段，那就需要创始人好好斟酌了。</p>

<p>　　第五、收购方的确认。为了防止利益冲突，创始人最好能够预先确定哪些方面的收购方不在领售权的有效范围之内，比如竞争对手、本轮VC投资过的其他公司、VC的关联公司等等。</p>

<p>　　第六、股东购买。如果有创始人不愿意出售公司，而VC一定要出售的话，那么还有一条解决办法就是由创始人以同样的价格和条件将VC的股份买下。如下图所示：</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/由创始人以同样的价格和条件将VC的股份买下.jpg"></p>

<p>　　第七、时间。最好能要求给予公司足够的成长时间，通常4、5年之后，如果VC仍然看不到IPO退出的机会，才允许激发领售权，通过出售公司退出。</p>

<p>　　第八、如果创始人同意VC出售公司，创始人可以要求不必为交易承担并购方要求的在业务、财务等方面的陈述、保证等义务。</p>

<p>　　综上所述，对于前文所示的条款，比较合理的谈判结果如下：</p>

<p>　　<strong>领售权</strong>：在本轮融资交割结束4年后，如果超过2/3的A类优先股股东和董事会同意出售全部或部分股份给一个真实的第三方，并且每股收购价格不低于本轮融资股价的3倍，则此优先股股东有权要求其他股东，其他股东也有义务按照相同的条款和条件出售他们的股份（全部或按相同比例），如果有股东不愿意出售，那么这些股东应该以不低于第三方的价格和条款购买其他股东的股份。</p>

<h3>领售权的一个真实案例</h3>

<p>　　美国有一家名叫FilmLoop的互联网公司，2005年1月向Garage Technology Ventures和Globespan Capital Partners融资550万美元，2006年5月，又向ComVentures融资700万美元。2006年10月，公司推出新的FilmLoop 2.0平台，公司和投资人都对前景乐观。可是2006年11月，由于出资人（LP）要求清理非盈利的投资项目，ComVentures让FilmLoop公司在年底之前找到买家。尽管创始人不愿意出售公司，但是ComVentures的股份比例较高，另外还握有领售权，可以强制其他投资人和创始人出售。2006年12月，由于公司在年底前找不到买家，ComVentures让自己投资的另外一个公司Fabrik收购了FilmLoop，收购价格仅仅只比公司在银行的存款（300万美元）略高。根据清算优先权条款，创始人和管理团队一无所获。</p>

<p>　　ComVentures让创始人在圣诞节假期的时候，在极短的时间内寻找合适买家的做法，显然是有意的。这样他们就可以让自己的关联利益方廉价收购FilmLoop。FilmLoop公司的创始人和员工在头一天还拥有一家公司，并且还有300万美元的银行存款，而第二天，他们发现自己失去了股票、失去工作、失去公司！</p>

<p>　　这种做法让创始人始料不及，但是如果诉诸法律，以后再创业的话，可能不会有VC敢投资他了。另外，为了自己的名声，创始人只能简单地认栽，并期望哪天能东山再起，遇到有“道德”的投资人，他们可以跟企业患难与共，不会强制出售一个正常运营的公司去解救另外一个公司。</p>

<p>　　这个案例告诉我们，VC的条款可以有些不太“道德”的用法，所以，融资的时候，要小心给钱的到底是谁。</p>

<h3>总论</h3>

<p>　　对VC来说，将领售权条款写入投资协议已经越来越重要了，如果正确设计和执行，领售权可以为VC提供重要的保护，使之在合适的时机可以实现投资退出。企业的创始人理应保障VC合理的退出要求，但也要通过精心的条款细节设计，控制自身可能面临的风险。</p>

<h2>风险投资协议（Term Sheet）详解之十：融资额</h2>

<blockquote><p>　　创业者愿意出让的股权比例、融资数额和公司估值三者之间，确定任意两个，上面等式就成立了。通常来说，创业者对出让股权的比例往往最先确定，一般不会超过40%，但也不会少于15%～20%，否则很难吸引VC的兴趣。</p></blockquote>

<p><img class="center" src="http://epingwang.me/images/2015/07/风险投资协议（Term" title="Sheet）详解之十：融资额.jpg" ></p>

<p>　　通常说来，在进行投资的时候，VC只关心2个问题：经济因素和控制因素。经济因素是指投资人最终能够获得的回报及影响回报的条款；控制因素是指允许投资人对公司业务实施正面的控制或者对公司的决策拥有否决权的机制。</p>

<p>　　因为经济因素更为直接，且与眼前利益相关，所以绝大部分创业者在融资的时候，更关注这类条款。而融资额和价格（或估值）条款，是最重要的经济因素条款，通常是创业者最为看重，也是最难以谈判的条款。</p>

<p>　　标准的融资额度条款如下：</p>

<p>　　Amount of Financing: An aggregate of $ X million, representing a Y % ownership position on a fully diluted basis, including shares reserved for any employee option pool. Prior to the Closing, the Company will reserve shares of its Common Stock so that Z % of its fully diluted capital stock following the issuance of its Series A Preferred is available for future issuances to directors, officers, employees and consultants.</p>

<p>　　<strong>融资额</strong>：合计$ X 百万美元，占公司完全稀释后股份（包括为员工期权池预留的股份）的 Y %。在融资交割前，公司将预留普通股，满足A类优先股发行后完全稀释时有 Z %的股份可供未来发放给董事、管理层、员工和顾问。</p>

<h3>估值、价格、融资数额的关系</h3>

<p>　　既然创业者是通过出让公司一部分股权的方式融资，那么就会涉及到几个问题：公司的估值是多少？VC购买的价格是多少？创业者出让的股权比例是多少？创业者需要融资的数额是多少？</p>

<p>　　首先，创业者要理解公司估值和价格的差异。通常而言的估值是指 “公平市场价值（Fair Market Value）”，即根据市场情况和公司实际状况，理应拥有的市场价值，所以“估值”是对公司内在价值的一种计算。VC给予公司的估值，实际上是“价格”，是VC主观上对公司的一种价值认可，是VC为得到公司股份所愿意支付的货币（或其他支付手段）。下面就是这两个概念的区别：</p>

<ul>
<li><p>公平市场价值是根据一个虚构的市场条件计算得到的，而价格是真实的；</p></li>
<li><p>公平市场价值假设双方的知识和谈判能力相同，而价格会受VC、创业者双方在信息、谈判力量上的不同的影响；</p></li>
<li><p>公平市场价值假设双方不受外部因素影响，而实际上VC、创业者双方都有某些情绪因素，尤其创业者更是受到资金压力的影响；</p></li>
<li><p>公平市场价值假设所有VC的判断力相同，而价格反应了有独特动机VC的影响；</p></li>
<li><p>公平市场价值假设市场中有大量VC有投资意愿，而实际上愿意投资的VC可能很少。</p></li>
</ul>


<p>　　尽管估值和价格有这么多差异，但基本上所有的讨论都使用“估值”来指“价格”，所以创业者要记住这一点，即创始人是跟VC讨论公司的股份可以卖多少钱，而不是值多少钱。
　　
　　既然是融资，那么融资数额是VC在听完创业者的融资演示后必然要问的一个问题。在公司估值（价格）确定之后，创业者应该出让给VC的股权比例就按以下公式确定了：</p>

<p>　　创业者愿意出让的股权比例、融资数额和公司估值三者之间，确定任意两个，上面等式就成立了。通常来说，创业者对出让股权的比例往往最先确定，一般不会超过40%，但也不会少于15%～20%，否则很难吸引VC的兴趣。</p>

<h3>VC在投资数额上的考虑因素</h3>

<p>　　对于VC来说，考虑到以下因素，他们也会在投资数额上面临两难选择：</p>

<ul>
<li><p>扩大投资组合。VC对投资过的公司并不是完全了解（肯定不如创业者了解多），并且每个公司都有各自的经营风险。这就导致VC要分散投资，降低单个投资对基金整体的风险。因此，VC对于单个公司的投资数额会控制在一定范围之下，以便建立一个大的、分散的投资组合。</p></li>
<li><p>给其他VC机会。VC投资时，很多时候希望有其他VC一起跟投，这样就需要给其他VC一些投资额度。更多的VC来关注和了解同一个公司，可以降低看走眼的风险。另外，更多的VC可以组建更出色的董事会，给予公司更多经营上的帮助。</p></li>
<li><p>投资成本。VC每投资一个项目，需要花费的时间和金钱都不少，如果他们认为某个项目值得投资，他们就会尽量多投资，这样才对得起这些付出的成本。如果不是这样，他们要花费更多的时间和金钱去寻找更多的好项目。</p></li>
<li><p>基金回报。如果VC确信某个项目能够成功，他们也会尽量多投资，这样能够提升整个基金的回报水平。</p></li>
</ul>


<p>　　创业者和投资人都面临不同的考虑因素，有经验的、有良好声誉的VC对于合理的融资额度有一定的职业感觉，并且能够跟创业者一起讨论一个合适的融资的额度。</p>

<h3>创业者在融资数额上的考虑因素</h3>

<p>　　其实，创业者通常是因为公司的发展需要资金才寻求融资，那么向VC要多少钱是摆在创业者面前的第一道难题，他们常常为此伤脑筋。对于这个问题也很难找到一个科学的答案，但创业者在确定一个合理的融资数额的时候要考虑以下因素：</p>

<p>　　<strong>（1）避免生存危机：多融资</strong></p>

<p>　　首先，公司的发展可能遇到没有预计到的挫折。也许是产品开发延误、质量问题、某重要客户破产、新竞争者出现、公司因知识产权被起诉、核心员工离职等。</p>

<p>　　第二，融资窗口在公司需要钱的时候不一定能打开。不同的时期，投资人对不同类型的行业、不同阶段的公司有兴趣。如果他们不感兴趣，融资窗口就关闭了，创业者很难说服他们，VC投资也是有跟风效应的。比如最近2年的Web 2.0公司，如果融资不足，可能无法获得后续融资，就会被洗牌。</p>

<p>　　第三，有些完全不可预期的灾难会发生。比如国家政策变化、经济危机、地震等，可能会导致公司融资窗口长期关闭。</p>

<p>　　这些因素会让创业者尝试尽量多融一些，这样公司会有充足的现金，如果公司遇到意外的情况，也不至于账上没钱。</p>

<p>　　<strong>（2）达到经营里程碑：多融资</strong></p>

<p>　　通常，创业者要融到足够1年使用的资金，或者能够满足公司发展到下一个重要里程碑之后6个月，对于不同的公司而言，里程碑可能是推出新产品、可能是产生收入。这个时间长度是考虑到创业者要给自己足够的时间来使用这笔资金，并且做出一定的业绩，并且为后续融资到位预留一定的时间窗口。融资过程比较麻烦，要应付不同的VC、一大堆会议、尽职调查等等，会消耗大量的时间和精力。没有必要第一轮融资一结束就迅速开始第二轮融资。</p>

<p>　　<strong>（3）少稀释股权：少融资</strong></p>

<p>　　第一轮融资少一点，少稀释一些。在后续轮融资时，公司的估值提高，这样多轮融资使公司的平均估值提高，创业者的股份也会被稀释少一些。</p>

<p>　　举个简单的例子：假设公司总共需要$20M就可以实现不错的退出，创业者可以选择：</p>

<ul>
<li><p>按投资前估值$10M，融资$20M，创始人出让2/3的股份；</p></li>
<li><p>分三轮融资：</p></li>
</ul>


<p>　　√ 第一轮按投资前估值$10M，融资$5M，创始人出让股份1/3，剩余股份2/3；</p>

<p>　　√ 第二轮按投资前估值$25M，融资$5M，创始人出让股份1/9（2/3*5/30），剩余5/9；</p>

<p>　　√ 第三轮按投资前估值$50M，融资$10M，创始人出让股份5/54（5/9*10/60），剩余25/54。</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/不同融资方案下的不同情况.jpg"></p>

<p>　　<strong>（4）当心VC的优先清算权：少融资</strong></p>

<p>　　如果VC投资后，公司被收购，那么当初融资越多，就需要以越高的价格出售，否则投资人拿走其一定倍数优先清算的额度之后，就很难给创业者和员工留下什么了。换句话说，创业者向VC融资太多的话，会让公司在并购机会来临时，难以以较低的价格成交。</p>

<p>　　如果创业者认为公司非常有可能将会被收购，而且收购价格不会太高，那么从自身回报的角度看，融资数额少一些是个好主意。</p>

<p>　　举个例子如下：</p>

<p>　　情况一：投资前估值$3M，投资$1M，VC获得公司25%股份，如果有2个创业者平分股份，2个创业者、员工各有5%的期权，在公司控制权变更时期权全部兑现；</p>

<p>　　情况二：投资前估值$15M，投资$5M，VC获得公司25%股份，如果有2个创业者平分股份，2个创业者、员工各有5%的期权，在公司控制权变更时期权全部兑现；</p>

<p>　　如果VC要求的优先清算倍数是3倍（3X），融资后半年，某公司要以$20M的价格收购创业者的公司。创业者各持有公司35%股份，在情况一之下，创业者分别可以得到$7M，VC得到$5M（回报5X大于优先清算倍数3X）其他期权持有人拿走剩余的。这种情况对所有人都不错。在情况二之下，VC会要求按优先清算倍数获得$15M，创业者分别得到$2.33M。VC基本满意，但创业者就不满意了。</p>

<p>　　<strong>（5）当心降价融资：少融资</strong></p>

<p>　　创业者融资的时候总是希望能够获得最高的估值，这样他们就能出让最少的股份获得最多的资金。但是，融资太多（公司估值太高），后续融资愿意跟进的VC会很少。如果下轮估值上升，跟进的VC更少，迫使当前VC继续追加投资或公司可能要降价融资。</p>

<p>　　降价融资对创业者来说是非常痛苦的，因为他们会损失大量的股份。这是因为大部分VC都会要求防稀释条款，如果后续降价融资，公司要对前期VC的投资价格进行调整，对应的前期VC的股份比例要增加。结果是创业者的股份比例下降了。VC这样做的目的就是防止创业者对公司经营不善，或者公司估值过高。有这个条款的存在，创业者就会选择合适的估值，保证公司后续的估值不断上升。</p>

<p>　　降价融资具有很大的破坏力，不仅仅大大影响创业者的股份比例，还会影响公司的整体士气和创始人与投资人之间的关系。</p>

<p>　　Fenwick &amp; West LLP在最近发布的针对美国硅谷的VC投资情况的一份报告显示，在2006年第3季度至2008年第2季度的2年里，投资价格下降的案例比例平均约为17%。</p>

<p><img class="center" src="http://epingwang.me/images/2015/07/2006年第3季度至2008年第2季度的2年里，投资价格下降的案例比例.jpg"></p>

<p>　　贪婪会受到惩罚的，也许创业者可以获得高额融资（高估值），但精明的VC知道在高估值的情况下如何保护自己。</p>

<h3>公司估值的确定</h3>

<p>　　有些VC会让创业者给自己的公司估值，如果创业者真的就大谈特谈各种估值方法，比如，贴现现金流法、可比公司法等等，最后给出一个数字，那就错了。创业者应该明白，在金融专业知识上，VC比你强太多了，你最佳的做法是：</p>

<ul>
<li><p>告诉VC，最重要的不是估值，而是找到正确的投资人；</p></li>
<li><p>反问VC，根据你们的经验，创业者的公司的估值范围应该在什么区间？</p></li>
<li><p>跟其他有意向的几个VC沟通，重复上面2点。</p></li>
</ul>


<p>　　相信创业者这样会对自己公司在市场的价格（估值）有个更为客观的认识。另外，根据经济规律，如果需求（VC感兴趣）大于供给（公司要出让的股份），价格就会上升。</p>

<p>　　对于公司的估值，没有一个通用的估值方法。不同的基金有自己的方法，对于不同阶段的公司也有不同的方法。对于早期公司而言，现金流贴现模型就不太适用，因为早期公司的未来现金流预测太不确定了。在美国硅谷，有些VC就有如下简易方法：</p>

<ul>
<li><p>有好的创意：$1M价值</p></li>
<li><p>产品产生销售：$1M价值</p></li>
<li><p>优秀的管理团队：$1-2M价值</p></li>
<li><p>优秀的董事会：$1M价值</p></li>
</ul>


<p>　　对于发展期、成熟期的公司，VC通常采用P/E倍数的方法估值，以VC投资后一个年度利润为计算基础，P/E倍数通常是5-10左右，不同发展阶段和行业的公司，倍数不同。</p>

<p>　　对于创业者，给自己公司定价是需要将艺术性、科学性和“其他因素”相结合。估值的艺术就是将公司在市场、管理、人员、及其他软性的因素考虑进去，让投资人产生兴趣。估值的科学就是以上市和非上市的可比公司为依据，看看他们的市值，根据公司的收入／利润预测，计算出自己公司的价值。估值的“其他因素”是考虑VC的基金大小、期望的持股比例、VC之间的竞争状况等。最终，得到一个创业者和投资人双方满意的估值。</p>

<h3>融资数额的确定</h3>

<p>　　好的VC知道，一旦他们投资了某公司，他们将成为公司创业团队中的一员，并期望创业者带着他们一起成功，这就注定VC要帮助创业者确定正确的融资数额。</p>

<p>　　创业者告诉VC的金额可能跟VC实际愿意投资的金额不同。一旦创业者开始跟VC合作，VC会根据公司的需求，建议你融更多、或者更少。因此，不要对融资数额这个问题感到太大的压力。</p>

<p>　　但是，你也要给VC一个合适的数额，因为如果你报出的数字在数量级上都不对的话，会把VC吓跑的，比如你只需要$5M时，你告诉VC说你融$50M。VC需要知道创业者如何得到这个数字，如何计划使用这笔资金，公司期望运用这笔资金达到的目标，是否可以少一些钱，如果有更多钱将如何使用？因此对VC来说，不是创业者想融资多少的问题，而是创业者应该融资多少的问题。</p>

<p>　　计算出融资额度也是一个艺术性多于科学性的问题，VC也明白这个问题没有答案。最好的答案不是一个数字，而是一个范围。融资下限能够满足公司业务发展，直到下一轮融资。而上限能够让公司更快达到短期发展目标，并为可能的风险预留足够资金。准备好告诉VC，不同融资数额下的资金使用计划，让他们能够了解，不同融资方案的差异在什么地方。</p>

<p>　　给出一个区间是最好的答案：</p>

<ul>
<li><p>让VC了解，资金如何驱动公司的发展；</p></li>
<li><p>让VC明白你对公司的运营和融资是有过深思熟虑的；</p></li>
<li><p>向VC表明你是一个灵活的合作伙伴，愿意为公司寻找最佳的方案；</p></li>
<li><p>创建出几个合理的公司发展情形，由VC选择。</p></li>
</ul>


<h3>总结</h3>

<p>　　创业者在他以什么样的价格融资这个问题上，面临的是一个不对称风险。如果融资的价格太低，他会被稀释过多，当然不满意，但不满意程度跟融资多少和估值大小有关系。另外一方面，如果他的价格太高，融资可能失败；即使融到资，未来可能面临“降价融资”等风险，这个后果就要严重很多。</p>

<p>　　（作者：桂曙光；电子邮箱：<a href="guishuguang@hotmail.com">guishuguang@hotmail.com</a>）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XCode7 Beta 下载地址]]></title>
    <link href="http://epingwang.me/blog/2015/06/10/xcode7-bet-xia-zai-di-zhi/"/>
    <updated>2015-06-10T11:15:27+08:00</updated>
    <id>http://epingwang.me/blog/2015/06/10/xcode7-bet-xia-zai-di-zhi</id>
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/services-account/download?path=/WWDC_2015/Xcode_7_beta/Xcode_7_beta.dmg">https://developer.apple.com/services-account/download?path=/WWDC_2015/Xcode_7_beta/Xcode_7_beta.dmg</a></p>

<p>创业项目招募UI设计师一名。现在手里有两个手机APP项目：其中一个客户端＋服务器程序全部完成，很快可以上线；另一个已经有完备的产品原型图以及非常靠谱的技术团队。本人在这两个项目中负责程序开发。在规定时间内兼职完成即可，在校学生只要有实力一样欢迎。</p>

<p>希望找到这样的你：
1. 对手机App有一定的审美，了解设计规范。
2. 有扎实的PS/Sketch绘图基础，能够根据原型图绘制界面、设计图标。
3. 有一定的沟通能力，迅速理解产品逻辑。
4. 有时间观念和自我驱动能力。</p>

<p>加分项：
1. 有过移动App产品设计经历。
2. 有Dribbble/Behance账号，在上面发表过作品的尤佳。
3. 有个人blog。</p>

<p>你可以得到的：
1. 现金报酬及初创项目的一部分股权。
2. 北京一二线互联网公司（BAT、乐视、京东、美丽说等）和最牛的创业公司（IDG、红杉、蓝驰、华创等顶级风投投资）的内推机会。
3. 一群有趣的朋友。</p>

<p>有兴趣请将你的作品发到我的邮箱：
<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x6d;&#x65;&#x40;&#x65;&#112;&#105;&#x6e;&#103;&#119;&#x61;&#x6e;&#x67;&#46;&#x6d;&#101;">&#109;&#x65;&#x40;&#x65;&#112;&#x69;&#110;&#x67;&#119;&#x61;&#110;&#x67;&#46;&#109;&#101;</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何创建Cocoapods的私有Spec]]></title>
    <link href="http://epingwang.me/blog/2015/05/11/ru-he-chuang-jian-cocoapodsde-si-you-spec/"/>
    <updated>2015-05-11T09:56:40+08:00</updated>
    <id>http://epingwang.me/blog/2015/05/11/ru-he-chuang-jian-cocoapodsde-si-you-spec</id>
    <content type="html"><![CDATA[<blockquote><p>很多项目使用 CocoaPods (<a href="">http://cocoapods.org/</a>) 管理项目依赖，非常方便的引入了大量的第三方开源代码。CocoaPods 项目本身也是开源的，这意味着可以很方便的通过 CocoaPods 管理私有/本地项目。</p></blockquote>

<h3>主要分为以下几步</h3>

<ol>
<li>创建一个私有 Spec Repo</li>
<li>创建并初始化适合 CocoaPods 管理的项目</li>
<li>创建并发布该项目的 podspec 描述文件</li>
<li>项目协作，Podfile编写</li>
</ol>


<h3>参考资料</h3>

<ul>
<li><a href="">http://guides.cocoapods.org/making/private-cocoapods.html</a></li>
<li><a href="">http://guides.cocoapods.org/making/using-pod-lib-create.html</a>
]</li>
</ul>


<!--more-->


<h2>Step 1: 创建一个私有 Spec Repo</h2>

<p>Spec Repo 是存放 CocoaPods 项目描述文件（.podspec）的仓库，其 master branch 由 CocoaPods 维护 (<a href="">https://github.com/CocoaPods/Specs</a>)。</p>

<p>创建私有 Spec Repo，我们不需要 fork master repo，只需要按照以下结构创建这样一个 Git 项目，并上传到 Git</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── Specs
</span><span class='line'>    └── [SPEC_NAME]
</span><span class='line'>        └── [VERSION]
</span><span class='line'>            └── [SPEC_NAME].podspec</span></code></pre></td></tr></table></div></figure>


<p>上传完成后，执行以下命令，将 Spec Repo 添加到本地。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod repo add REPO_NAME SOURCE_URL</span></code></pre></td></tr></table></div></figure>


<h2>Step 2: 创建并初始化适合 CocoaPods 管理的项目</h2>

<p>我们可以手动创建一个开源项目，也可以通过 CocoaPods 的模版创建。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod lib create DemoLibrary</span></code></pre></td></tr></table></div></figure>


<p>在 Bash 中执行该命令，创建一个名为 DemoLibrary 的模版，我们可以看到项目结构如下:</p>

<p><img class="center" src="http://epingwang.me/images/2015/05/20150511-1@2x.png"></p>

<p>在 Podspec Metadata 文件夹中，提供了非常重要的三个文件:</p>

<ul>
<li>.podspec 是该项目的描述文件</li>
<li>README.md 大家都懂的</li>
<li>LICENSE 默认提供了一个 MIT 许可协议</li>
</ul>


<p>我们将需要创建的 Class 放入<code>./Pod/Classes</code>中，将资源文件放入<code>./Pod/Assets</code>中，将项目 push 到你的 Git Repo。</p>

<h2>Step 3: 创建并发布该项目的 podspec 描述文件</h2>

<p>我们在 Demo 项目中，已经生成了一个<code>DemoLibrary.podspec</code>文件。如果没有使用模版生成项目，我们需要使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod spec create [NAME|https://github.com/USER/REPO]</span></code></pre></td></tr></table></div></figure>


<p>命令来创建<code>.podspec</code>文件。</p>

<p>打开该文件，根据注释编写自己的 podspec 即可。</p>

<p>在提交之前，我们需要使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod spec lint DemoLibrary.podspec</span></code></pre></td></tr></table></div></figure>


<p>来验证 podspec 的合法性。</p>

<p>如果验证通过，我们可以用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod repo push REPO_NAME SPEC_NAME.podspec</span></code></pre></td></tr></table></div></figure>


<p>提交这个 podspec</p>

<h4>Note:</h4>

<p>我们在使用<code>$ pod spec lint</code>和<code>$ pod repo push</code>命令时，会收到各种 warning 或者 error，导致提交失败。</p>

<p>使用<code>--allow-warnings</code>来忽略一些 warning。</p>

<h2>Step 4: 项目协作，Podfile编写</h2>

<p>首先，如果需要你的小伙伴们也使用你的项目，需要他们安装 CocoaPods，并执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod repo add REPO_NAME SOURCE_URL</span></code></pre></td></tr></table></div></figure>


<p>在他们项目的 Podfile 中，加入你的开源项目，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>platform :ios, ‘8.0’
</span><span class='line'>
</span><span class='line'>target 'DemoApp' do
</span><span class='line'>
</span><span class='line'>source 'https://github.com/CocoaPods/Specs.git'
</span><span class='line'>pod 'GPUImage', '~&gt; 0.1.6'
</span><span class='line'>
</span><span class='line'>source 'git@git.github.com:YourPrivateRepo/specs.git'
</span><span class='line'>pod 'CocoaHelpers', '~&gt; 1.0.0'
</span><span class='line'>
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>注意: 在 CocoaPods 0.36.0版本之后，需要显示指定 source，否则会出现<code>Unable to find a specification for XXX</code>错误。</p>

<p>执行<code>pod install</code>，大功告成！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些有意思的问题]]></title>
    <link href="http://epingwang.me/blog/2015/05/04/%5B%3F%5D-xie-you-yi-si-de-wen-ti/"/>
    <updated>2015-05-04T11:02:14+08:00</updated>
    <id>http://epingwang.me/blog/2015/05/04/[?]-xie-you-yi-si-de-wen-ti</id>
    <content type="html"><![CDATA[<blockquote><p>前几天一个朋友问了一些蛮有意思的问题，在这里总结一下</p></blockquote>

<h3>@property 中 NSString 的属性为什么要用 copy</h3>

<hr />

<p>NSString 是 NSMutableString 的基类，在赋值时，对这两个情况要分开讨论：</p>

<h4>当传入 NSString 对象时</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2015-05-04 11:09:04.270 StringTest[540:218144] content = 0x10010e4a8
</span><span class='line'>2015-05-04 11:09:04.271 StringTest[540:218144] self.content = 0x10010e4a8</span></code></pre></td></tr></table></div></figure>


<p>赋值操作直接把传入的 NSString 的内存地址赋给 self.content</p>

<h4>当传入 NSMutableString 对象时</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2015-05-04 11:09:04.271 StringTest[540:218144] mutable content = 0x17406ec40
</span><span class='line'>2015-05-04 11:09:04.271 StringTest[540:218144] self.content = 0x17403b4a0</span></code></pre></td></tr></table></div></figure>


<p>赋值操作创建了一个新的 NSString 并赋值给 self.content</p>

<h4>这样做的意义：</h4>

<p>NSString 是不可变对象，用 copy 属性可以保证传入 NSMutableString 后，其引用的值始终不变。</p>

<h3>ViewController 中的一些调用问题</h3>

<hr />

<h4>loadView 在什么时候调用</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="n">retain</span><span class="p">)</span> <span class="n">UIView</span> <span class="o">*</span><span class="n">view</span><span class="p">;</span> <span class="c1">// The getter first invokes [self loadView] if the view hasn&#39;t been set yet. Subclasses must call super if they override the setter or getter.</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">loadView</span><span class="p">;</span> <span class="c1">// This is where subclasses should create their custom view hierarchy if they aren&#39;t using a nib. Should never be called directly.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里注释解释的比较清楚，在调用<code>someViewController.view</code>时，如果<code>view == nil</code>，则首先调用<code>[self loadView]</code></p>

<p>那么可以推断出，<code>[self viewDidLoad]</code>的调用是在<code>[self loadView]</code>之后。</p>

<h4>viewDidLoad 可以调用几次</h4>

<p>最开始想当然的认为只能调用一次。</p>

<p>实际上在iOS6之前，当 Application 收到 Memory warning 之后，会将 hierarchy 中不在前台显示的 viewController.view 设为 nil，并调用<code>- (void)didReceiveMemoryWarning</code>, <code>- (void)viewWillUnload;</code>, <code>- (void)viewDidUnload</code>方法。</p>

<p>在iOS6之后，默认不会卸载view，但是也可以在<code>- (void)didReceiveMemoryWarning</code>中手动卸载掉。</p>

<p>当被卸载的view进入屏幕时，会重新加载，并调用<code>[self viewDidLoad]</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8中可交互通知(NotificationAction)初探]]></title>
    <link href="http://epingwang.me/blog/2015/01/16/ios8zhong-ke-jiao-hu-tong-notificationaction-chu-tan/"/>
    <updated>2015-01-16T15:30:39+08:00</updated>
    <id>http://epingwang.me/blog/2015/01/16/ios8zhong-ke-jiao-hu-tong-notificationaction-chu-tan</id>
    <content type="html"><![CDATA[<p>iOS8中，可交互推送/通知可以在<strong>锁屏界面/通知中心/推送消息Banner</strong>上以按钮形式与App交互。</p>

<h2>注册可交互推送</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIMutableUserNotificationAction</span> <span class="o">*</span><span class="n">acceptAction</span> <span class="o">=</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIMutableUserNotificationAction</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 回调时按钮的ID</span>
</span><span class='line'><span class="n">acceptAction</span><span class="p">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s">@&quot;ACCEPT_IDENTIFIER&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 按钮title(Facebook使用了emoji)</span>
</span><span class='line'><span class="n">acceptAction</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">@&quot;Accept&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* UIUserNotificationActivationModeBackground </span>
</span><span class='line'><span class="cm">* APP会在后台启动</span>
</span><span class='line'><span class="cm">* UIUserNotificationActivationModeForeground</span>
</span><span class='line'><span class="cm">* APP会在前台启动</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="n">acceptAction</span><span class="p">.</span><span class="n">activationMode</span> <span class="o">=</span> <span class="n">UIUserNotificationActivationModeBackground</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// YES为红色，NO为蓝色</span>
</span><span class='line'><span class="n">acceptAction</span><span class="p">.</span><span class="n">destructive</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 是否需要解锁</span>
</span><span class='line'><span class="n">acceptAction</span><span class="p">.</span><span class="n">authenticationRequired</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">UIMutableUserNotificationCategory</span> <span class="o">*</span><span class="n">category</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIMutableUserNotificationCategory</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 消息的ID(区分服务器推送过来时消息的种类)</span>
</span><span class='line'><span class="n">category</span><span class="p">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s">@&quot;INVITE_CATEGORY&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Alert形式展现的推送</span>
</span><span class='line'><span class="p">[</span><span class="n">category</span> <span class="nl">setActions:</span><span class="err">@</span><span class="p">[</span><span class="n">acceptAction</span><span class="p">]</span> <span class="nl">forContext:</span><span class="n">UIUserNotificationActionContextDefault</span><span class="p">];</span>
</span><span class='line'><span class="c1">// Banner/锁屏形式展现的推送</span>
</span><span class='line'><span class="p">[</span><span class="n">category</span> <span class="nl">setActions:</span><span class="err">@</span><span class="p">[</span><span class="n">acceptAction</span><span class="p">]</span> <span class="nl">forContext:</span><span class="n">UIUserNotificationActionContextMinimal</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">UIUserNotificationSettings</span> <span class="o">*</span><span class="n">settings</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIUserNotificationSettings</span> <span class="nl">settingsForTypes:</span>
</span><span class='line'><span class="n">UIUserNotificationTypeAlert</span> <span class="o">|</span> <span class="n">UIUserNotificationTypeBadge</span> <span class="o">|</span> <span class="n">UIUserNotificationTypeSound</span> <span class="nl">categories:</span><span class="p">[</span><span class="n">NSSet</span> <span class="nl">setWithObject:</span><span class="n">category</span><span class="p">]];</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">registerUserNotificationSettings:</span><span class="n">settings</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Discussion:</h4>

<ul>
<li>当Contenxt为<code>UIUserNotificationActionContextMinimal</code>时，最多展现两个按钮。</li>
<li>当Contenxt为<code>UIUserNotificationActionContextDefault</code>时，最多展现四个按钮。</li>
<li>当Contenxt为<code>UIUserNotificationActionContextMinimal</code>时，第一个按钮在右边，第二个按钮在左边。</li>
<li>当Contenxt为<code>UIUserNotificationActionContextMinimal</code>时，若两个按钮的<code>destructive</code>属性都为NO，则第一个为蓝色，第二个为灰色。</li>
<li>当Contenxt为<code>UIUserNotificationActionContextDefault</code>时，按钮顺序由上到下排列。</li>
</ul>


<h2>Schedule推送</h2>

<!--more-->


<h4>Remote Notifications</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;aps&quot;</span> <span class="p">:</span> <span class="p">{</span>
</span><span class='line'>       <span class="nt">&quot;alert&quot;</span> <span class="p">:</span> <span class="s2">&quot;You’re invited!&quot;</span><span class="p">,</span>
</span><span class='line'>       <span class="nt">&quot;category&quot;</span> <span class="p">:</span> <span class="s2">&quot;INVITE_CATEGORY&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Local Notifications</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UILocalNotification</span> <span class="o">*</span><span class="n">notification</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILocalNotification</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="c1">///...</span>
</span><span class='line'>
</span><span class='line'><span class="n">notification</span><span class="p">.</span><span class="n">category</span> <span class="o">=</span> <span class="s">@&quot;INVITE_CATEGORY&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">scheduleLocalNotification:</span><span class="n">notification</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>推送处理</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 当收到推送时，会调用这两个方法</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">handleActionWithIdentifier:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">forRemoteNotification:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">userInfo</span> <span class="nf">completionHandler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">completionHandler</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">handleActionWithIdentifier:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">forLocalNotification:</span><span class="p">(</span><span class="n">UILocalNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notification</span> <span class="nf">completionHandler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">completionHandler</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 当执行完事件处理的代码后，调用`completionHandler()`，通知系统处理完成</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Discussion:</h4>

<ul>
<li>虽然在WWDC视频中，提到事件处理的时间限定在几秒钟，但是实际上在子线程执行一次网络请求等异步操作也是可以的，甚至连网络超时事件都可以拿到。只需要在网络请求结束后再调用<code>completionHandler()</code>即可。（猜测: 几秒钟的限制应该是主线程的执行时间）</li>
<li>我是否只能调用静态方法: 经过简单的实验，当App在后台，但进程未被<strong>Terminate</strong>时，是可以读取App内的数据的，但不会调用<code>applicationDidBecomeActive</code>。若App进程被<strong>Terminate</strong>后，用户点击按钮后会先加在App，调用<code>application: didFinishLaunchingWithOptions</code>。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoapods提速手册]]></title>
    <link href="http://epingwang.me/blog/2014/12/24/cocoapodsti-su-shou-ce/"/>
    <updated>2014-12-24T11:09:14+08:00</updated>
    <id>http://epingwang.me/blog/2014/12/24/cocoapodsti-su-shou-ce</id>
    <content type="html"><![CDATA[<p>转自 <a href="http://www.codingtime.info/post/posts/leng-zhi-shi/2014_07_28_speed_up_cocoapods">CodingTime</a></p>

<blockquote><p>前言</p>

<p>相信大家在使用cocoapods的时候，都感到在墙内速度怨念把。今天po主我在家更新代码时执行&#8217;pod install
居然花了2个小时，各种怒从中来，遂整理了一下cocoapods提速的各种方法，给大家参考。</p></blockquote>

<h3>1.cocoapods安装提速</h3>

<p>我们在使用&#8217;gem install cocoapods&#8217;来安装cocoapods时，是不是感觉都奇慢无比？都是gem官方源被墙惹的祸！将gem的默认官方镜像更换成淘宝镜像可以解决这一问题。在命令行中执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources --remove https://rubygems.org/
</span><span class='line'>gem sources -a https://ruby.taobao.org/
</span><span class='line'>gem sources -l</span></code></pre></td></tr></table></div></figure>


<p>若显示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*** CURRENT SOURCES ***
</span><span class='line'>
</span><span class='line'>https://ruby.taobao.org</span></code></pre></td></tr></table></div></figure>


<p>则淘宝源替换成功。这是再执行gem install cocoapods会发现安装速度明显变快。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>注意：
</span><span class='line'>更换淘宝gem镜像只是提高cocoapods安装速度和更新速度，不会影响任何pod命令的速度。＝  ＝</span></code></pre></td></tr></table></div></figure>


<h3>2. 获取specs文件提速</h3>

<p>cocoapods的spec文件都放在github中，而国内访问github总有些不顺畅，导致每次更新cocoapods spec文件都时候速度都比较慢。将cocoapods的spec版本库改成国内可以提升spec文件的更新速度。</p>

<p>在命令行中执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod repo remove master
</span><span class='line'>pod repo add master https://gitcafe.com/akuandev/Specs.git
</span><span class='line'>pod repo update</span></code></pre></td></tr></table></div></figure>


<p>默认的cocoapods master仓库会被替换成国内gitcafe仓库。</p>

<h3>3. pod install提速</h3>

<p>每次执行<code>pod install</code>和<code>pod update</code>的时候，cocoapods都会默认更新一次spec仓库。这是一个比较耗时的操作。在确认spec版本哭不需要更新时，给这两个命令加一个参数跳过spec版本库更新</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod install --verbose --no-repo-update
</span><span class='line'>pod update --verbose --no-repo-update</span></code></pre></td></tr></table></div></figure>


<p>可以明显提高这两个命令的执行速度。</p>

<h3>4. 终极提速大法</h3>

<p>在将gem、cocoapods spec文件都改成国内镜像之后，剩下的还能提速的步骤就是将各个pod的源码也拖到国内了。不过将pod list里5000多个pod全部镜像下来并一一修改spec文件，这工程量完全不是我等小屌丝能够完成的。目前似乎也没有哪个牛逼大厂完成这个壮举。所以所谓的终极提速大法，就是无论干什么最终都得有个好用的梯子。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7以上系统中，UITextView输入滚动错位的bug]]></title>
    <link href="http://epingwang.me/blog/2014/12/05/ios7yi-shang-xi-tong-zhong-%2Cuitextviewshu-ru-gun-dong-cuo-wei-de-bug/"/>
    <updated>2014-12-05T18:20:23+08:00</updated>
    <id>http://epingwang.me/blog/2014/12/05/ios7yi-shang-xi-tong-zhong-,uitextviewshu-ru-gun-dong-cuo-wei-de-bug</id>
    <content type="html"><![CDATA[<p>在iOS7中，<code>UITextView</code>多了一个<code>textContainer</code>属性用来描述一些Layout。</p>

<p>在用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UITextView</span> <span class="o">*</span><span class="n">textView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UITextView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法时，并没用初始化textContainer，会导致输入中文时页面滚动出现bug。修复这个bug，用以下的方法初始化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">SomeTextView</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">IOS7</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSTextStorage</span><span class="o">*</span> <span class="n">textStorage</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSTextStorage</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="n">NSLayoutManager</span><span class="o">*</span> <span class="n">layoutManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSLayoutManager</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">textStorage</span> <span class="nl">addLayoutManager:</span><span class="n">layoutManager</span><span class="p">];</span>
</span><span class='line'>        <span class="n">NSTextContainer</span> <span class="o">*</span><span class="n">textContainer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSTextContainer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSize:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">someWidth</span><span class="p">,</span> <span class="n">someHeight</span><span class="p">)];</span>
</span><span class='line'>        <span class="n">textContainer</span><span class="p">.</span><span class="n">widthTracksTextView</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="n">textContainer</span><span class="p">.</span><span class="n">heightTracksTextView</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="n">layoutManager</span> <span class="nl">addTextContainer:</span><span class="n">textContainer</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">initWithFrame:</span><span class="n">CGRectZero</span> <span class="nl">textContainer:</span><span class="n">textContainer</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithFrame:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">IOS7</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSTextStorage</span><span class="o">*</span> <span class="n">textStorage</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSTextStorage</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="n">NSLayoutManager</span><span class="o">*</span> <span class="n">layoutManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSLayoutManager</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">textStorage</span> <span class="nl">addLayoutManager:</span><span class="n">layoutManager</span><span class="p">];</span>
</span><span class='line'>        <span class="n">NSTextContainer</span> <span class="o">*</span><span class="n">textContainer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSTextContainer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSize:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">kDeviceHeight</span><span class="p">)];</span>
</span><span class='line'>        <span class="n">textContainer</span><span class="p">.</span><span class="n">widthTracksTextView</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="n">textContainer</span><span class="p">.</span><span class="n">heightTracksTextView</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="n">layoutManager</span> <span class="nl">addTextContainer:</span><span class="n">textContainer</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">initWithFrame:</span><span class="n">frame</span> <span class="nl">textContainer:</span><span class="n">textContainer</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">initWithFrame:</span><span class="n">frame</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScrollsToTop 使用小结]]></title>
    <link href="http://epingwang.me/blog/2014/10/23/scrollst-shi-yong-xiao-jie/"/>
    <updated>2014-10-23T17:17:19+08:00</updated>
    <id>http://epingwang.me/blog/2014/10/23/scrollst-shi-yong-xiao-jie</id>
    <content type="html"><![CDATA[<p>我们经常会看到，很多App中点击StatusBar，tableView就会滚回顶部。</p>

<p>在<code>UIScrollView</code>中，<code>scrollsToTop</code>这个属性可以实现这个效果。</p>

<p>iOS官方注视中是这样解释的</p>

<blockquote><p>  When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its <code>scrollsToTop</code> property is YES, its delegate does not return NO from <code>shouldScrollViewScrollToTop</code>, and it is not already at the top.</p>

<p>  On iPhone, we execute this gesture only if there&rsquo;s one on-screen scroll view with <code>scrollsToTop</code> == YES. If more than one is found, none will be scrolled.</p></blockquote>

<p>简单翻译一下:</p>

<blockquote><p>  当用户点击status bar, 靠近status bar的scroll view会滚动到顶端。但只有 <code>scrollsToTop</code>属性设为YES，代理中<code>shouldScrollViewScrollToTop</code>方法返回YES，并且scroll view没有在顶端时会生效。</p>

<p>  在iPhone中，只有当前屏幕中只有一个scroll view的<code>scrollsToTop</code>属性为YES时，该手势才会执行。如果有多个，任何一个scroll view都不会滚动。</p></blockquote>

<p>在实际使用中，我们可能会用到很多UIScrollView的派生类，例如:</p>

<ul>
<li>UITableView</li>
<li>UICollectionView</li>
<li>UITextView</li>
<li>UIWebView中也有一个UIScrollView</li>
</ul>


<p>我写了一个小工具来检测当前View中，包含的UIScrollView</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">UIView</span> <span class="nl">(Utility)</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">checkConflictScrollViews</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="n">subView</span> <span class="k">in</span> <span class="n">self</span><span class="p">.</span><span class="n">subviews</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">subView</span> <span class="n">checkConflictScrollViews</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">([</span><span class="n">subView</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">UIScrollView</span> <span class="n">class</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="p">[(</span><span class="n">UIScrollView</span> <span class="o">*</span><span class="p">)</span><span class="n">subView</span> <span class="n">scrollsToTop</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">subView</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AppStore审核经验分享]]></title>
    <link href="http://epingwang.me/blog/2014/09/24/appstoreshen-he-jing-yan-fen-xiang/"/>
    <updated>2014-09-24T10:32:16+08:00</updated>
    <id>http://epingwang.me/blog/2014/09/24/appstoreshen-he-jing-yan-fen-xiang</id>
    <content type="html"><![CDATA[<p>原文链接 <a href="http://blog.sina.com.cn/s/blog_4b4ddfea0102v07f.html">SAM1023的博客</a></p>

<p>最近苹果审核更严厉了，我们产品新版（陪你看电影App）提交也接连被苹果Reject，平均更新审核周期也在12天左右。前两天3.3.0新版终于尼玛审核通过了，前后花了一个多月时间也是醉了，中间的各种苦逼心酸和无奈不提也罢，总结下经验教训吧。当然，审核不通过可以有太多的原因，大家可以参考苹果最新公布的审核指南，我在这里只聊聊我们这次新版提交审核遇到的一些问题。</p>

<!--more-->


<h3>关于“第三方登录”</h3>

<blockquote><p>10.6 Apple and our customers place a high value on simple, refined, creative, well thought through interfaces. They take more work but are worth it. Apple sets a high bar. If your user interface is complex or less than very good, it may be rejected.</p>

<p>(Apple和我们的用户都对界面报以很高期望，希望他设计的超级简洁，精致，充满创造力，深思熟虑。做到这些确实会消耗很多精力，但是值得。Apple在这方面要求非常高。如果你的用户界面过于复杂，甚至仅仅是不够好，都可能被拒。)</p></blockquote>

<p>很多产品都流行使用第三方平台账户做单点登录，比如微博、QQ和微信登录，可以拉低用户注册成本，甚至可以拉取第三方平台的好友关系链。</p>

<p>实际的体验场景是当用户当前设备安装了第三方客户端时，可以直接调用第三方客户端进行验证登录，但是，如果用户当前设备没有安装第三方客户端，则通常是会弹出H5的授权验证页面，但因为这个页面有被钓鱼的风险，新版QQ登录SDK是不提供这种方式进行验证授权的，就有了如下图所示的结果。</p>

<p><img class="center" src="images/2014/09/qq_login.jpeg"></p>

<p>虽然苹果Reject的理由是他们认为这个界面的体验违背了上述的10.6条款，但实际上苹果应该也是<strong>不允许在应用内有阻碍用户继续操作的行为包括提示引导用户去下载第三方App的行为</strong>。</p>

<h4>解决方式：</h4>

<p>用户在打开应用时如果检测到当前设备已安装手Q则显示QQ登录按钮，反之，则隐藏QQ登录按钮。还有一种做法是当用户打开应用时如果没检测到手Q则提示“未安装XX客户端，请选择其它登录方式或安装XX客户端后再进行登录”（这种方式我没有验证过）。</p>

<h3>关于“Advertising Identifier (IDFA)”</h3>

<blockquote><p>PLA 3.3.12  We found your app uses the iOS Advertising Identifier but does not include ad functionality. This does not comply with the terms of the iOS Developer Program License Agreement, as required by the App Store Review Guidelines</p>

<p>（我们发现你的应用使用了IDFA，但并没有提供广告功能，这不符合苹果App Store审核规范关于iOS开发者协议的条款）。</p></blockquote>

<p>Advertising Identifier就是所谓的IDFA，是每台iOS设备的唯一标识符，IDFA的使用必须有明确的广告用途才被允许，苹果在前两年宣布淘汰UDID后，IDFA成为提供精确广告的唯一方法。很多开发者包括第三方数据统计分析平台都会在统计激活安装量时使用到IDFA，比如积分墙厂商在跟CP结算数据时也都倾向使用IDFA。
苹果审核一般会检测以下三个调用判断你是否使用IDFA：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class: ASIdentifierManager
</span><span class='line'>selector: advertisingIdentifier
</span><span class='line'>framework: AdSupport.framework</span></code></pre></td></tr></table></div></figure>


<p><strong>如果你希望在应用内展示广告，但又想使用IDFA，请尝试以下：</strong></p>

<p>在应用内插一个可在后台自主关闭的展示Banner展示，比如使用有米或友盟的广告SDK（虽然有米的这个Banner广告也未使用到IDFA），通过审核后如果不要这个广告再把Banner条关闭掉。一定要注意的是尽量把这个广告放在比较容易被发现的位置，如果放在深层目录的话最好在提交的时候说明如何locate Ads。有做积分墙朋友建议使用苹果的iAD广告框架，插上素材，用户点击后跳转到淘宝、天猫等电商页面，其实这也有个风险，因为Banner右下角会显示来自iAD的广告，而审核人员知道iAD是没有使用IDFA的，这可能会成为reject的理由（事实上，这也是我们被Reject的理由）。</p>

<p>还有一种方案是不做任何代码修改，在提交的时候勾选第三项“将在这款应用内采取的措施归因于之前发布的广告”（我没有验证过）。</p>

<p><img class="center" src="http://epingwang.me/images/2014/09/idfa.jpeg"></p>

<h3>关于“应用内活动”</h3>

<blockquote><p>20.2 Official rules for sweepstakes and contests, must be presented in the App and make it clear that Apple is not a sponsor or involved in the activity in any manner.</p>

<p>（ 应用中必须展示赌博和竞赛的官方条款，并声明Apple不是资助者，并且在任何情况下与此事无关。）</p></blockquote>

<p>也许你应用内活动真的跟苹果公司无半毛钱关系，也保不准一定能通过审核，很简单，在活动页声明“本活动与苹果公司无关”即可，但还是建议不要在审核期间上线类似送壕机的活动。</p>

<p><img class="center" src="http://epingwang.me/images/2014/09/in_app_activity.png"></p>

<h3>关于“应用推荐”</h3>

<p>关于“应用推荐”不用多说了，跟很多苹果助手类产品一样，苹果很早就表示拒绝这类软件和功能的上架（仅接受推自家产品），不过依然有很多CP为了换量的需求而上这个功能，虽然有些能侥幸通过审核，但还是不建议在审核期展示出来。</p>

<p><img class="center" src="http://epingwang.me/images/2014/09/app_advertise.png"></p>

<h3>关于“支持ARM64bit”</h3>

<p>尽管自从iPhone5s开始处理器已支持64bit，且苹果在官网上要求开发者开发的应用必须兼容32位和64位处理器，但显然不管是平台还是开发者大多还没有重视这块。9月10日下午一直到第二天凌晨，大量开发者反映因为ARM64问题导致无法提交Build，出错信息如下。</p>

<p><img class="center" src="http://epingwang.me/images/2014/09/arm64_error.jpeg"></p>

<p>截至目前除了微信及友盟有提供64位SDK版本外，其它主流第三方平台SDK都还木有更新。虽然，第二天早上这个问题已不再出现，但是兼容64位已是大势所趋，建议开发者可以着手考虑调整64位架构了。</p>

<p><img class="center" src="http://epingwang.me/images/2014/09/apple_forum.jpeg"></p>

<h3>关于“加急审核”</h3>

<p>不是每个人的加急审核申请都能被通过，一般来说如果你的当前线上产品有很致命的严重影响用户使用的Bug申请加急审核都能被通过，当然也有因为市场活动原因申请加急审核申请被通过的。</p>

<p>一旦你的加急审核申请通过了，你的App会在一个工作日内被处理，如果这期间因为可能出现的其它问题导致再次被reject，你只需要重新提交修改后的build或补充说明（metadata reject）就行，你的App将会一直处于加急审核队列，直到审核通过。</p>

<p>苹果加急审核邮箱：<a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#65;&#112;&#x70;&#x52;&#x65;&#x76;&#105;&#101;&#x77;&#64;&#97;&#112;&#112;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;">&#x41;&#x70;&#112;&#82;&#101;&#118;&#x69;&#101;&#x77;&#64;&#x61;&#x70;&#112;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></p>

<p>网页提交地址：<a href="https://developer.apple.com/appstore/contact/?topic=expedite">https://developer.apple.com/appstore/contact/?topic=expedite</a></p>

<p>最后，允许我自私的给自家产品打个广告吧，陪你看电影——好电影，要分享！ 一键下载链接：<a href="http://www.3ovie.com">http://www.3ovie.com</a> 或在App Store和各大Android商店搜索“陪你看电影”。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 关于地理位置的获取]]></title>
    <link href="http://epingwang.me/blog/2014/09/23/ios8-guan-yu-di-li-wei-zhi-de-huo-qu/"/>
    <updated>2014-09-23T17:32:39+08:00</updated>
    <id>http://epingwang.me/blog/2014/09/23/ios8-guan-yu-di-li-wei-zhi-de-huo-qu</id>
    <content type="html"><![CDATA[<h3>在iOS8之前</h3>

<p>当我们调用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CLLocationManager</span> <span class="o">*</span><span class="n">locationManager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CLLocationManager</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">locationManager</span> <span class="n">startUpdatingLocation</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法时，会自动弹出警告，请求用户通过地理位置权限</p>

<h3>iOS8中</h3>

<p>获取地理位置的权限默认为<code>kCLAuthorizationStatusNotDetermined</code>，即未确定权限。当调用<code>startUpdatingLocation</code>时，不会自动请求获取权限。</p>

<p>Apple文档中的解释</p>

<p><strong>&ndash; (void)requestWhenInUseAuthorization 中: </strong></p>

<blockquote><p>You must call this method or the requestAlwaysAuthorization method prior to using location services. If the user grants “when-in-use” authorization to your app, your app can start most (but not all) location services while it is in the foreground. (Apps cannot use any services that automatically relaunch the app, such as region monitoring or the significant location change service.) When started in the foreground, services continue to run in the background if your app has enabled background location updates in the Capabilities tab of your Xcode project. Attempts to start location services while your app is running in the background will fail. The system displays a location-services indicator in the status bar when your app moves to the background with active location services.</p></blockquote>

<!--more-->


<p><strong>简单解释:</strong></p>

<p>当请求地理位置之前，必须先显式调用<code>-(void)requestWhenInUseAuthorization</code>或者<code>- (void)requestAlwaysAuthorization</code>方法，当用户通过请求时，前者可以在程序前台运行时获取地理位置，后者则可以在程序后台运行时继续获取位置，并可唤醒程序</p>

<h4>其他的事项</h4>

<ul>
<li><p>请求时和在设置中显示的文本:</p>

<p>  在<code>Info.plist</code>中修改，Key为<code>NSLocationWhenInUseUsageDescription</code>或<code>NSLocationAlwaysUsageDescription</code></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7网络请求]]></title>
    <link href="http://epingwang.me/blog/2014/08/19/ios7wang-luo-qing-qiu/"/>
    <updated>2014-08-19T18:20:37+08:00</updated>
    <id>http://epingwang.me/blog/2014/08/19/ios7wang-luo-qing-qiu</id>
    <content type="html"><![CDATA[<h3>NSURLSession</h3>

<p>NSURLSession，提供后台链接，当APP关闭时也可以下载/上传</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 创建</span>
</span><span class='line'><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nl">backgroundSessionConfiguration:</span><span class="s">@&quot;identifier&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSession</span> <span class="nl">sessionWithConfiguration:</span><span class="n">conf</span> <span class="nl">delegate:</span><span class="n">self</span> <span class="nl">delegateQueue:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用</span>
</span><span class='line'><span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="nl">requestWithURL:</span><span class="p">[</span><span class="n">NSURL</span> <span class="nl">URLWithString:</span><span class="s">@&quot;Some URL&quot;</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="p">[</span><span class="n">session</span> <span class="nl">downloadTaskWithRequest:</span><span class="n">request</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">task</span> <span class="n">resume</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>当Session下载/上传完成后，如果APP不在前台，iOS会自动启动APP，并且调用这个方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">handleEventsForBackgroundURLSession:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">completionHandler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">completionHandler</span>
</span></code></pre></td></tr></table></div></figure>


<p>session的代理会收到回调</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession:</span><span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span> <span class="nf">downloadTask:</span><span class="p">(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span> <span class="nf">didFinishDownloadingToURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadURL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="err">其中</span><span class="n">downloadURL</span><span class="err">中的</span><span class="n">Data</span><span class="err">就是下载完成的</span><span class="n">Data</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将NSDate转为RFC822格式的时间戳]]></title>
    <link href="http://epingwang.me/blog/2014/08/05/jiang-nsdatezhuan-wei-rfc822ge-shi-de-shi-jian-chuo/"/>
    <updated>2014-08-05T16:55:43+08:00</updated>
    <id>http://epingwang.me/blog/2014/08/05/jiang-nsdatezhuan-wei-rfc822ge-shi-de-shi-jian-chuo</id>
    <content type="html"><![CDATA[<p>HTTP/1.1 Protocol中要求的时间戳格式有以下三个:</p>

<pre><code>  Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
  Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
  Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
</code></pre>

<p>其中应用最广泛的是的RFC822格式</p>

<p>转换方法如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSDateFormatter</span> <span class="o">*</span><span class="n">df</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">df</span><span class="p">.</span><span class="n">locale</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSLocale</span> <span class="nl">localeWithLocaleIdentifier:</span><span class="s">@&quot;en-us&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">df</span><span class="p">.</span><span class="n">timeZone</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimeZone</span> <span class="nl">timeZoneWithAbbreviation:</span><span class="s">@&quot;GMT&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">df</span><span class="p">.</span><span class="n">dateFormat</span> <span class="o">=</span> <span class="s">@&quot;EEE&#39;,&#39; dd MMM yyyy HH&#39;:&#39;mm&#39;:&#39;ss &#39;GMT&#39;&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">dateString</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span> <span class="nl">stringFromDate:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextField的默认Placeholder颜色]]></title>
    <link href="http://epingwang.me/blog/2014/07/10/uitextfieldde-mo-ren-placeholderyan-se/"/>
    <updated>2014-07-10T14:11:44+08:00</updated>
    <id>http://epingwang.me/blog/2014/07/10/uitextfieldde-mo-ren-placeholderyan-se</id>
    <content type="html"><![CDATA[<h3>色值为</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>R:0
</span><span class='line'>G:0
</span><span class='line'>B:0.0980392
</span><span class='line'>A:0.22</span></code></pre></td></tr></table></div></figure>


<h3>查看方式</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSRange</span> <span class="n">range</span> <span class="o">=</span> <span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="p">[</span><span class="n">someTextField</span><span class="p">.</span><span class="n">attributedPlaceholder</span> <span class="nl">attributesAtIndex:</span><span class="mi">0</span> <span class="nl">effectiveRange:</span><span class="o">&amp;</span><span class="n">range</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">dict</span> <span class="nl">objectForKey:</span><span class="n">NSForegroundColorAttributeName</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小试Auto Layout——VFL篇]]></title>
    <link href="http://epingwang.me/blog/2014/06/13/xiao-shi-auto-layout-vflpian/"/>
    <updated>2014-06-13T18:47:42+08:00</updated>
    <id>http://epingwang.me/blog/2014/06/13/xiao-shi-auto-layout-vflpian</id>
    <content type="html"><![CDATA[<h3>为什么要AutoLayout</h3>

<p>从iOS6开始，移动端开始支持AutoLayout。与传统的Layout方法相比，AutoLayout不再使用Origin+Size的方式描述View的位置和大小，而是使用<code>Constraints</code>（约束）来描述。</p>

<p>AutoLayout的优点:</p>

<ul>
<li>iOS设备越来越多，iPhone4/5/6、iPad、甚至以后的AppleTV、iWatch，其分辨率都是不一样的，要做分辨率适配，旧的方法已经不再适合，AutoLayout提供了一个适配不同分辨率的方式。</li>
<li>在iOS8中，View的尺寸可以通过设备旋转、Universal适配、SplitView展开/折叠等途径不断改变，就要求subview的位置和尺寸适应parent view。</li>
<li>将View的布局计算交给View自己，而不需要在ViewController中控制，更加符合MVC。</li>
</ul>


<h3>为什么要用VFL</h3>

<p>VFL，即Visual Format Language，是用code编码进行AutoLayout的方式。</p>

<p>VFL的优点:</p>

<ul>
<li>编写简单，工作量少，代码可读性强，方便维护。</li>
<li>由于处理的是字符串，所以符合OC的动态特性。</li>
<li>程序员忍受得了去IB拖积木吗？</li>
</ul>


<h3>VFL语法</h3>

<!--more-->


<h4>创建一个VFL约束:</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">NSLayoutConstraint</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">constraintsWithVisualFormat:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">format</span> <span class="nf">options:</span><span class="p">(</span><span class="n">NSLayoutFormatOptions</span><span class="p">)</span><span class="nv">opts</span> <span class="nf">metrics:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">metrics</span> <span class="nf">views:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">views</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中:</p>

<ul>
<li>@param format: VFL语句</li>
<li>@param opts: 约束方式，见后续</li>
<li>@param metrics: 约束中固定值的字典，Value必须是NSNumber</li>
<li>@param views: 约束语句中用到的view的字典</li>
<li>@return 返回一个NSArray，其中Object为<code>NSLayoutConstraint</code>类型</li>
</ul>


<p>其返回值用这个方法接收:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">UIView</span> <span class="nl">(UIConstraintBasedLayoutInstallingConstraints)</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addConstraints:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">constraints</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">6</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>NSLayoutFormatOptions</h4>

<p>在写VFL时，遇到一个问题，我很难描述一个View需要居中的约束。</p>

<p>通过计算左右边界与SuperView边界的距离是可以实现的，但很明显背离了VFL的初衷。</p>

<p>查阅文档后发现这些选项就在<code>opts</code>这个参数中，不但可以设置居中，也可以设计约束的参考位置，以及对其方式，可以用位运算选择多个方式。</p>

<h4>一行VFL语句:</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">(</span><span class="o">&lt;</span><span class="n">orientation</span><span class="o">&gt;:</span><span class="p">)</span><span class="o">?</span>
</span><span class='line'><span class="p">(</span><span class="o">&lt;</span><span class="n">superview</span><span class="o">&gt;&lt;</span><span class="n">connection</span><span class="o">&gt;</span><span class="p">)</span><span class="o">?</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">view</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">connection</span><span class="o">&gt;&lt;</span><span class="n">view</span><span class="o">&gt;</span><span class="p">)</span><span class="o">*</span>
</span><span class='line'><span class="p">(</span><span class="o">&lt;</span><span class="n">connection</span><span class="o">&gt;&lt;</span><span class="n">superview</span><span class="o">&gt;</span><span class="p">)</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure>


<p>例如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="s">@&quot;V:|-vSpace-[_touchImageView(==avatarHeight)]-vPad-[_nameTextField(==textFieldHeight)]&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>orientation:</p>

<p>  <code>
V: 纵向约束
H: (默认)横向约束
</code></p></li>
<li>superview: <code>|</code></li>
<li><p>view:</p>

<p>  <code>[&lt;viewname&gt;(&lt;predicateListWithParens)?]</code></p></li>
<li><p>connection:</p>

<p>  <code>-padding-</code>，其中padding可以使matrics字典中的某一项，也可以是一个数值，如<code>-20-</code></p></li>
<li><p>predicateListWithParens:</p>

<p>  <code>(&lt;predicate&gt;(,&lt;predicate&gt;)*)</code>，一组predicate，用逗号隔开</p></li>
<li><p>predicate:</p>

<p>  <code>(&lt;relation&gt;)?(&lt;objectOfPredicate&gt;)(@&lt;priority&gt;)?</code>，例如(>=vPad@100)，意义为宽/高大于vPad（metrics字典中一项），优先级为100</p></li>
</ul>


<h4>注意事项:</h4>

<ul>
<li>一行VFL中，所有被约束的View一定是添加约束View的SubView</li>
<li><p>被约束的View要设置</p>

<p>  <code>
  [someView setTranslatesAutoresizingMaskIntoConstraints:NO];]
 </code></p></li>
<li><p>使用VFL之后，系统不再调用这个方法</p>

<p>  <code>
  -(void) setFrame:(CGRect)frame
 </code></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Session 214 View Controller Advancements for iOS8 笔记]]></title>
    <link href="http://epingwang.me/blog/2014/06/11/session-214-view-controller-advancements-for-ios8-bi-ji/"/>
    <updated>2014-06-11T15:52:27+08:00</updated>
    <id>http://epingwang.me/blog/2014/06/11/session-214-view-controller-advancements-for-ios8-bi-ji</id>
    <content type="html"><![CDATA[<p>Session 214</p>

<p>Bruce D. Nilo</p>

<h2>OverView</h2>

<ul>
<li>A brief discussion about UIKit&rsquo;s new Adaptive APIs</li>
<li>New UISplitViewController features</li>
<li>Some new ways to condense and hide bars</li>
<li>Presentations and popovers</li>
<li>New API that uses transition coordinators</li>
<li>Coordinate spaces</li>
</ul>


<!--more-->


<h2>Support for Adaptive User Interfaces</h2>

<p>Universal App中，相同的页面会展示为不同的Layout</p>

<p>在iOS8之前，Layout取决于</p>

<ul>
<li>设备类型      Device type</li>
<li>设备方向      Interface Orientation</li>
<li>Window大小  Size</li>
</ul>


<p>iOS8之后:</p>

<ul>
<li>Traits and trait collections</li>
<li>Size</li>
</ul>


<h3>什么是 &ldquo;trait collection&rdquo;?</h3>

<p>Trait collection 是一个trait的集合</p>

<p>例如: 在一个竖屏的 iPhone5s 中</p>

<table>
<thead>
<tr>
<th>Trait </th>
<th> Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>horizontalSizeClass </td>
<td> Compact</td>
</tr>
<tr>
<td>verticalSizeClass </td>
<td> Regular</td>
</tr>
<tr>
<td>userInterfaceIdiom </td>
<td> Phone</td>
</tr>
<tr>
<td>displayScale </td>
<td> 2.0</td>
</tr>
</tbody>
</table>


<h3>什么是 &ldquo;size class&rdquo;?</h3>

<ul>
<li>Size class 是简单定义<code>可用空间</code>的一个 <code>trait</code></li>
<li>可以定义在Horizontal方向和Vertical方向是Compact or Regular</li>
</ul>


<h3>Trait Environments</h3>

<p>在iOS8中, <code>UIView</code>和<code>UIViewController</code>均 conforms <code>&lt;UITraitEnvironment&gt;</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@protocol</span> <span class="nc">UITraitEnvironment</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">UITraitCollection</span> <span class="o">*</span><span class="n">traitCollection</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">traitCollectionDidChange:</span><span class="p">(</span><span class="n">UITraitCollection</span> <span class="o">*</span><span class="p">)</span><span class="nv">previousTraitCollection</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>并不是每个View都有自己的TraitCollection，当获取<code>Leaf View</code>的<code>traitCollection</code>时，会沿着View的hierarchy找到最近的traitCollection</p>

<h2>Split View Controller</h2>

<p>UISplitViewControllers can now be used on the phone</p>

<p>新增了这个方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">UISplitViewController</span> : <span class="nc">UIViewController</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isCollapsed</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">collapsed</span>  <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">8</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Expanded split view controller</h4>

<p><img class="center" src="http://epingwang.me/images/2014/06/SplitViewController.jpg"></p>

<h4>Collapsed split view controller</h4>

<p><img class="center" src="http://epingwang.me/images/2014/06/SplitViewControllerCollapsed.jpg"></p>

<h3>在ViewController中添加SplitViewcontroller，并启用Collapse</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">svc</span><span class="p">.</span><span class="n">preferredDisplayMode</span> <span class="o">=</span> <span class="n">UISplitViewControllerDisplayModeAllVisible</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>控制分栏的宽度</h3>

<p>通过以下几个属性</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">preferredPrimaryColumnWidthFraction</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">8</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">minimumPrimaryColumnWidth</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">8</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">maximumPrimaryColumnWidth</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">8</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="n">readonly</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">primaryColumnWidth</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">8</span><span class="n">_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Condesing Bars</h2>

<p>现在隐藏NavigationBar和ToolBar变得相当简单，只需要以下几个属性</p>

<p>自动隐藏:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readwrite</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">condensesBarsOnSwipe</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readwrite</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">condensesBarsWhenKeyboardAppears</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readwrite</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">hidesBarsWhenVerticallyCompact</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readwrite</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">hidesBarsOnTap</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">barHideGestureRecognizer</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>手动控制:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readwrite</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">getter</span> <span class="o">=</span> <span class="n">isNavigationBarCondensed</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">navigationBarCondensed</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Session 216 Building Adaptive Apps With UIKit]]></title>
    <link href="http://epingwang.me/blog/2014/06/10/session-216-building-adaptive-apps-with-uikit/"/>
    <updated>2014-06-10T17:32:04+08:00</updated>
    <id>http://epingwang.me/blog/2014/06/10/session-216-building-adaptive-apps-with-uikit</id>
    <content type="html"><![CDATA[<p>Session 216</p>

<p>Jacob Xiao</p>

<p>使用UIKit 创建 Universial App</p>

<!--more-->


<h2>Summary</h2>

<ul>
<li>Adaptive Concepts</li>
<li>View Controllers</li>
<li>Interface Builder</li>
</ul>


<h3>Size Classes</h3>

<p>之前区分设备方向，使用 <code>UIInterfaceOrientation</code>(iPhone) 和 <code>UIUserInterfaceIdiom</code>(iPad)</p>

<p>现在用 <code>Size Classes</code> 取代</p>

<p>在iPad上:</p>

<ul>
<li>Potrait: Regular Horizontal &amp; Regular Vertical</li>
<li>Landscape: Regular Horizontal &amp; Regular Vertical</li>
</ul>


<p>在iPhone上:</p>

<ul>
<li>Potrait: Compact Horizontal &amp; Regular Vertical</li>
<li>Landscape: Compact Hotizontal &amp; Compact Vertical</li>
</ul>


<h3>UITraitCollection</h3>

<h4>成员:</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">UIUserInterfaceSizeClass</span> <span class="n">horizontalSizeClass</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">UIUserInterfaceSizeClass</span> <span class="n">verticalSizeClass</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">displayScale</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">UIUserInterfaceIdiom</span> <span class="n">userInterfaceIdiom</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Trait Environments</h4>

<ul>
<li>UIScreen</li>
<li>UIWindow</li>
<li>UIViewController</li>
<li>UIView</li>
<li>UIPresentationController</li>
</ul>


<p>所有层级共享同样的<code>UITraitCollection</code></p>

<p>当<code>TraitCollection</code>发生改变时，触发</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">traitCollectionDidChange:</span><span class="p">(</span><span class="n">UITraitCollection</span> <span class="o">*</span><span class="p">)</span><span class="nv">previousTraitCollection</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>重写这个方法来响应方向变化事件</p>

<h4>Trait Collections</h4>

<p>可以自己创建<code>UITraitCollection</code></p>

<p>可适用于横屏播放器之类的界面</p>

<p>可用于UITraitCollection的比较</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UITraitCollection</span> <span class="o">*</span><span class="n">collection</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">traitCollection</span><span class="p">;</span>
</span><span class='line'><span class="n">UITraitCollection</span> <span class="o">*</span><span class="n">newCollection</span> <span class="o">=</span> <span class="p">[</span><span class="n">UITraitCollection</span> <span class="nl">traitCollectionWithHorizontalSizeClass:</span><span class="n">UIUserInterfaceSizeClassCompact</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">collection</span> <span class="nl">containsTraitsInCollection:</span><span class="n">newCollection</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以合并<code>UITraitCollection</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">UITraitCollection</span> <span class="o">*</span><span class="p">)</span><span class="nf">traitCollectionWithTraitsFromCollections:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">traitCollections</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>Compact</code> + <code>Regular</code> = <code>Regular</code></p>

<h3>Appearance Proxy</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span><span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">appearanceForTraitCollection:</span><span class="p">(</span><span class="n">UITraitCollection</span> <span class="o">*</span><span class="p">)</span><span class="nv">trait</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Customize views for different traits</li>
<li>UIImage 可以响应这个方法，返回different version of image</li>
<li>UIImageAssets</li>
</ul>


<h3>Adaptive View Controllers</h3>

<h4>Split View Controller</h4>

<p>现在Split View Controller 是Universal的</p>

<h4>生命周期</h4>

<p>Setup开始时:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">willTransitionToTraitCollection:</span><span class="p">(</span><span class="n">UITraitCollection</span> <span class="o">*</span><span class="p">)</span><span class="nv">newCollection</span> <span class="nf">withTransitionCoordinator:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">UIViewControllerTransitionCoordinator</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">coordinator</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个方法可以自定义动画，并执行completion block，其顺序在下面方法之后。</p>

<p>Setup结束时:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">traitCollectionDidChange:</span><span class="p">(</span><span class="n">UITraitCollection</span> <span class="o">*</span><span class="p">)</span><span class="nv">previousTraitCollection</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Showing View Controllers</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">navigationController</span> <span class="nl">pushViewController:</span><span class="p">...];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个机制被废弃</p>

<p>取而代之的是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">showViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">vc</span> <span class="nf">sender:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">showDetailViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">vc</span> <span class="nf">sender:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两个方法总是保证，无论当前ViewController被包含在<code>NavigationController</code>, <code>SplitViewController</code>, 还是没有被包含在任何ViewController中，都会有正确的表现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Session 202 What's New in Cocoa Touch 笔记]]></title>
    <link href="http://epingwang.me/blog/2014/06/10/session-202-whats-new-in-cocoa-touch-bi-ji/"/>
    <updated>2014-06-10T15:24:54+08:00</updated>
    <id>http://epingwang.me/blog/2014/06/10/session-202-whats-new-in-cocoa-touch-bi-ji</id>
    <content type="html"><![CDATA[<p>Session 202</p>

<p>Luke Hiesterman</p>

<p>Core idea iOS8 &ndash;> Adaptivity</p>

<!--more-->


<h2>Adaptive Layout</h2>

<p>Orientations, sizes, and margins</p>

<h3>Adaptive Interface Orientation</h3>

<p>Layout 不再关心设备的方向以及设备的类型，而只关心屏幕画布的尺寸</p>

<p>范例: UITraitCollection
成员属性:</p>

<ul>
<li>horizontalSizeClass</li>
<li>displayScale</li>
<li>userInterfaceIdiom</li>
<li>verticalSizeClass</li>
</ul>


<p>UIViewController Conforms to <code>UITraitEnviroment</code>
当屏幕尺寸变化（设备方向改变）时，会调用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">traitCollectionDidChange:</span><span class="p">(</span><span class="n">UITraitCollection</span> <span class="o">*</span><span class="p">)</span><span class="nv">previousTraitCollection</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 使用Layout设置CollectionView</span>
</span><span class='line'>    <span class="n">UITraitCollection</span> <span class="o">*</span><span class="n">currentTraits</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">traitCollection</span><span class="p">;</span>
</span><span class='line'>    <span class="n">UICollectionViewLayout</span> <span class="o">*</span><span class="n">newLayout</span> <span class="o">=</span> <span class="n">currentTraits</span><span class="p">.</span><span class="n">horizontalSizeClass</span> <span class="o">==</span> <span class="n">UIUserInterfaceSizeClassCompact</span> <span class="o">?</span> <span class="n">self</span><span class="p">.</span><span class="n">squaresLayout</span> <span class="o">:</span> <span class="n">self</span><span class="p">.</span><span class="n">rectanglesLayout</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span> <span class="nl">setCollectionViewLayout:</span><span class="n">newLayout</span> <span class="nl">animated:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Adaptive Margins</h3>

<p>UIViewController 的属性:</p>

<ul>
<li>bottomLayoutGuide</li>
<li>topLayoutGuide</li>
<li>leftLayoutGuide</li>
<li>rightLayoutGuide</li>
</ul>


<p>可以确定四个边界（不用计算Navigation、ToolBar的高度）</p>

<p>See More: <a href="http://epingwang.github.io/blog/2014/06/10/session-216-building-adaptive-apps-with-uikit/">Building Adaptive Apps with UIKit</a></p>

<h3>Adaptive View Controllers</h3>

<h4>Rotation Deprecations</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">willRotateToInterfaceOrientation:</span><span class="p">(</span><span class="n">UIInterfaceOrientation</span><span class="p">)</span><span class="nv">toInterfaceOrientation</span> <span class="nf">duration:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">duration</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">willAnimateFirstHalfOfRotationToInterfaceOrientation:</span><span class="p">(</span><span class="n">UIInterfaceOrientation</span><span class="p">)</span><span class="nv">toInterfaceOrientation</span> <span class="nf">duration:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">duration</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didRotateFromInterfaceOrientation:</span><span class="p">(</span><span class="n">UIInterfaceOrientation</span><span class="p">)</span><span class="nv">fromInterfaceOrientation</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">shouldAutomaticallyForwardRotationMethods</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">UIInterfaceOrientation</span><span class="p">)</span><span class="nf">interfaceOrientation</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">rotatingFooterView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">rotatingHeaderView</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>取而代之的新方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillTransitionToSize:</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="nv">size</span> <span class="nf">withTransitionCoordinator:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">UIViewControllerTransitionCoordinator</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">coordinator</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">8</span><span class="n">_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Adaptive View Controller Hierarchies</h3>

<h4>UISplitViewController</h4>

<p>Primary &ndash; Secondary (TableView &ndash; Detail) 视图</p>

<p>现在可以用<code>Split View Controller - Detail View Controller</code></p>

<ul>
<li>全设备支持</li>
<li>处理 <code>primary-secondary</code> 样式的视图交互</li>
<li>增强的可定制性</li>
</ul>


<p>See more: <a href="">View Controller Advancements in iOS8</a></p>

<h3>Adaptive Presentations</h3>

<p>适应不同设备的 <code>弹出视图(Popovers)</code>、<code>SearchBar</code>、<code>警告(Alerts)</code></p>

<h4>Popovers</h4>

<p>iPad上不再需要<code>UIPopOverController</code>，<code>Popover</code>以后做为UIViewController的Style使用
在iPhone上显示为PresentViewController样式</p>

<h4>Search Results</h4>

<p><code>UISearchDisplayController</code> replaced by</p>

<p><code>UISearchController</code> &ndash;> <code>UIViewController</code> subclass</p>

<ul>
<li><p>可以使用UIViewController的一切特性</p></li>
<li><p>可以定制UISearchController的UI</p></li>
</ul>


<h4>Alerts</h4>

<p><code>UIAlertController</code> replaces <code>UIAlertView</code> and <code>UIActionSheet</code></p>

<p>UIAlertController 也是 UIViewController 的 subclass</p>

<p>See More: <a href="">A Look Inside Presentation Controllers</a></p>

<h2>Testing with the iOS Simulator</h2>

<p>Simulator 可以直接调整 Size</p>

<ul>
<li>Resizeable iPhone</li>
<li>Resizeable iPad</li>
</ul>


<h2>Visual Effects</h2>

<p>UIVisualEffectView</p>

<p>可以接收<code>UIEffect</code>，来影响View及Subview上的Layer</p>

<ul>
<li>UIBlurEffect</li>
<li>UIVibrancyEffect</li>
</ul>


<h2>Image Assets</h2>

<p>直接返回正确的图片</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">imageNamed:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span>
</span><span class='line'>               <span class="nf">inBundle:</span><span class="p">(</span><span class="n">NSBundle</span> <span class="o">*</span><span class="p">)</span><span class="nv">bundle</span>
</span><span class='line'><span class="nf">compatibleWithTraitCollection:</span><span class="p">(</span><span class="n">UITraitCollection</span> <span class="o">*</span><span class="p">)</span><span class="nv">traitCollection</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Condensing Bars</h2>

<p>当用户滚动Scroll时，Navigation Bar 变小</p>

<p>See More: <a href="">Creating Custom iOS User Interfaces</a></p>

<h2>Self-sizing Table Cells</h2>

<p><strong> cell的 <code>height</code> 将无需在 <code>heightForRowAtIndexPath:</code> 中实现 </strong></p>

<p>cell 可以自己计算它的尺寸</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithStyle:</span><span class="p">(</span><span class="n">UITableViewCellStyle</span><span class="p">)</span><span class="nv">style</span> <span class="nf">reuseIdentifier:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">reuseIdentifier</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">initWithStyle:</span><span class="n">style</span> <span class="nl">reuseIdentifier:</span><span class="n">reuseIdentifier</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">contentView</span> <span class="nl">addConstraints:</span><span class="p">[</span><span class="n">NSLayoutConstraint</span>
</span><span class='line'>                                          <span class="nl">constraintsWithVisualFormat:</span><span class="s">@&quot;V:|-myTextView-|&quot;</span>
</span><span class='line'>                                          <span class="nl">options:</span><span class="mi">0</span>
</span><span class='line'>                                          <span class="nl">metrics:</span><span class="nb">nil</span>
</span><span class='line'>                                            <span class="nl">views:</span><span class="n">NSDictionaryOfVariableBindings</span><span class="p">(</span><span class="n">_myTextView</span><span class="p">)]];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">contentView</span> <span class="nl">addConstraints:</span><span class="p">[</span><span class="n">NSLayoutConstraint</span>
</span><span class='line'>                                          <span class="nl">constraintsWithVisualFormat:</span><span class="s">@&quot;H:|-myTextView-|&quot;</span>
</span><span class='line'>                                          <span class="nl">options:</span><span class="mi">0</span>
</span><span class='line'>                                          <span class="nl">metrics:</span><span class="nb">nil</span>
</span><span class='line'>                                            <span class="nl">views:</span><span class="n">NSDictionaryOfVariableBindings</span><span class="p">(</span><span class="n">_myTextView</span><span class="p">)]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>See More: <a href="">What&rsquo;s new in Table and Collection Views</a></p>

<h2>App Extensions</h2>

<p>可以写系统增强插件，例如在<code>Photo</code>中调用我们写的<code>Filter软件</code>或者<code>Share Extention</code></p>

<ul>
<li>Photo</li>
<li>Sharing</li>
<li>Notification Center Widgets</li>
<li>Action without UI</li>
<li>Document providers (向其他应用提供内容的Extension)</li>
<li>Custom keyboards</li>
</ul>


<p>See More: <a href="">Creating Extensions for iOS and OS X</a></p>

<h2>Notification Updates</h2>

<ul>
<li>不需要Show UI的Notification，不再需要用户的Permission</li>
<li>Notification可以进行用户交互</li>
<li>可以进行基于地理位置的Notification</li>
<li>payload size (256 bytes &ndash;> 1k)</li>
</ul>


<p>See More: <a href="">What&rsquo;s New in iOS Notifications</a></p>

<h2>Document Picker</h2>

<p>UIDocumentPickerViewController</p>

<p>System UI for selection documents</p>

<ul>
<li>Local documents</li>
<li>iCloud documents</li>
<li>Third-party document providers</li>
</ul>


<p>See more: <a href="">Building a Document-based App</a></p>

<h2>SDK Modernization</h2>

<ul>
<li>NS_DESIGNATED_INITIALIZER</li>
<li>id &ndash;> instancetype</li>
<li>Additional @properties</li>
</ul>


<h2>Handoff</h2>

<ul>
<li>通过Handoff用户可以在多设备之间共享操作</li>
<li>UIKit 和 AppKit 均支持 Handoff</li>
</ul>


<p>See More: <a href="">Adopting Handoff on iOS and OS X</a></p>

<h2>More Goodies in iOS</h2>

<h2>Photos</h2>

<ul>
<li>Photo Library 的读写权限</li>
<li>Custom CoreImage Filters</li>
</ul>


<p>See More: <a href="">Introducing the Photos Frameword</a></p>

<h2>CloudKit</h2>

<ul>
<li>更多的API，控制iCloud上的数据</li>
<li>创建一个 C/S App，无需搭设服务器</li>
</ul>


<p>See More: <a href="">Introducing CloudKit</a></p>

<h2>HealthKit</h2>

<p>See More: <a href="">Introducing HealthKit</a></p>

<h2>HomeKit</h2>

<p>See More: <a href="">Introducing HomeKit</a></p>

<h2>Local Authentication</h2>

<p>开放的指纹识别系统</p>

<ul>
<li>TouchID</li>
</ul>


<p>See More: <a href="">Keychain and Authentication with Touch ID</a></p>

<h2>SceneKit</h2>

<p>跨设备的3D渲染——For iOS</p>

<h2>Core Location</h2>

<ul>
<li>可以获得 Indoor Location，获得精确的楼层信息</li>
<li>更省电</li>
<li>当使用时获得用户的授权</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://epingwang.me/blog/2014/06/10/hello-world/"/>
    <updated>2014-06-10T14:58:19+08:00</updated>
    <id>http://epingwang.me/blog/2014/06/10/hello-world</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Hello world</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
